<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DXF to SVG Converter for Laser Cutting</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 8px;
            font-size: 1.8rem;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 24px;
            font-size: 0.95rem;
        }

        .dropzone {
            border: 3px dashed #ccc;
            border-radius: 12px;
            padding: 48px 24px;
            text-align: center;
            background: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 20px;
        }

        .dropzone:hover,
        .dropzone.dragover {
            border-color: #007bff;
            background: #f0f7ff;
        }

        .dropzone-text {
            color: #666;
            font-size: 1.1rem;
        }

        .dropzone-text strong {
            color: #007bff;
        }

        .dropzone input[type="file"] {
            display: none;
        }

        .controls {
            display: flex;
            gap: 16px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            color: #555;
            font-size: 0.9rem;
        }

        select {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 0.9rem;
            background: #fff;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: #007bff;
            color: #fff;
        }

        .btn-primary:hover:not(:disabled) {
            background: #0056b3;
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .status {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .status.error {
            display: block;
            background: #fee;
            color: #c00;
            border: 1px solid #fcc;
        }

        .status.success {
            display: block;
            background: #efe;
            color: #060;
            border: 1px solid #cfc;
        }

        .status.info {
            display: block;
            background: #eef;
            color: #006;
            border: 1px solid #ccf;
        }

        .preview-container {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 12px;
            padding: 20px;
            display: none;
        }

        .preview-container.visible {
            display: block;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .preview-title {
            font-size: 1rem;
            color: #333;
        }

        .dimensions {
            font-size: 0.9rem;
            color: #666;
            background: #f5f5f5;
            padding: 6px 12px;
            border-radius: 4px;
        }

        .preview-area {
            background: #fafafa;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            overflow: auto;
        }

        .preview-area svg {
            max-width: 100%;
            max-height: 500px;
            background: #fff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .filename {
            font-family: monospace;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .supported-entities {
            margin-top: 24px;
            padding: 16px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.85rem;
            color: #666;
        }

        .supported-entities strong {
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DXF to SVG Converter</h1>
        <p class="subtitle">Convert DXF files to SVG for Glowforge and other laser cutters</p>

        <div class="dropzone" id="dropzone">
            <p class="dropzone-text">
                <strong>Drop a DXF file here</strong><br>
                or click to browse
            </p>
            <input type="file" id="fileInput" accept=".dxf">
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="unitSelect">Input units:</label>
                <select id="unitSelect">
                    <option value="auto">Auto-detect</option>
                    <option value="mm">Millimeters (mm)</option>
                    <option value="in">Inches</option>
                </select>
            </div>
            <button class="btn btn-primary" id="downloadBtn" disabled>Download SVG</button>
        </div>

        <div class="status" id="status"></div>

        <div class="preview-container" id="previewContainer">
            <div class="preview-header">
                <span class="preview-title">Preview: <span class="filename" id="previewFilename"></span></span>
                <span class="dimensions" id="dimensions"></span>
            </div>
            <div class="preview-area" id="previewArea"></div>
        </div>

        <div class="supported-entities">
            <strong>Supported DXF entities:</strong> LINE, CIRCLE, ELLIPSE, ARC, LWPOLYLINE, POLYLINE, SPLINE<br>
            <strong>Note:</strong> TEXT and DIMENSION entities are not supported. Convert text to paths in your CAD software before exporting.<br>
            <a href="https://github.com/borgel/bad-dxf-svg" style="color: #007bff;">View source on GitHub</a>
        </div>
    </div>

    <script>
        // ============================================
        // Inline DXF Parser - No external dependencies
        // ============================================

        class DxfParser {
            parse(dxfString) {
                const lines = dxfString.split(/\r?\n/);
                const entities = [];
                let i = 0;

                // Find ENTITIES section
                while (i < lines.length) {
                    if (lines[i].trim() === 'ENTITIES') {
                        i++;
                        break;
                    }
                    i++;
                }

                // Parse entities
                while (i < lines.length) {
                    const code = parseInt(lines[i].trim(), 10);
                    const value = lines[i + 1] ? lines[i + 1].trim() : '';

                    if (code === 0) {
                        if (value === 'ENDSEC' || value === 'EOF') break;

                        const entityType = value;
                        i += 2;
                        const result = this.parseEntity(entityType, lines, i);
                        if (result) {
                            i = result.nextIndex;
                            if (result.entity) {
                                entities.push(result.entity);
                            }
                        }
                    } else {
                        i += 2;
                    }
                }

                return { entities };
            }

            parseEntity(type, lines, startIndex) {
                const entity = { type };
                let i = startIndex;

                const groupValues = {};

                while (i < lines.length) {
                    const code = parseInt(lines[i].trim(), 10);
                    const value = lines[i + 1] ? lines[i + 1].trim() : '';

                    if (code === 0) {
                        // Next entity or end of section
                        break;
                    }

                    // Store group codes
                    if (!groupValues[code]) {
                        groupValues[code] = [];
                    }
                    groupValues[code].push(value);

                    i += 2;
                }

                // Parse based on entity type
                switch (type) {
                    case 'LINE':
                        entity.start = {
                            x: parseFloat(groupValues[10]?.[0] || 0),
                            y: parseFloat(groupValues[20]?.[0] || 0)
                        };
                        entity.end = {
                            x: parseFloat(groupValues[11]?.[0] || 0),
                            y: parseFloat(groupValues[21]?.[0] || 0)
                        };
                        break;

                    case 'CIRCLE':
                        entity.center = {
                            x: parseFloat(groupValues[10]?.[0] || 0),
                            y: parseFloat(groupValues[20]?.[0] || 0)
                        };
                        entity.radius = parseFloat(groupValues[40]?.[0] || 0);
                        break;

                    case 'ARC':
                        entity.center = {
                            x: parseFloat(groupValues[10]?.[0] || 0),
                            y: parseFloat(groupValues[20]?.[0] || 0)
                        };
                        entity.radius = parseFloat(groupValues[40]?.[0] || 0);
                        entity.startAngle = parseFloat(groupValues[50]?.[0] || 0);
                        entity.endAngle = parseFloat(groupValues[51]?.[0] || 0);
                        break;

                    case 'ELLIPSE':
                        entity.center = {
                            x: parseFloat(groupValues[10]?.[0] || 0),
                            y: parseFloat(groupValues[20]?.[0] || 0)
                        };
                        entity.majorAxis = {
                            x: parseFloat(groupValues[11]?.[0] || 1),
                            y: parseFloat(groupValues[21]?.[0] || 0)
                        };
                        entity.ratio = parseFloat(groupValues[40]?.[0] || 1);
                        entity.startAngle = parseFloat(groupValues[41]?.[0] || 0);
                        entity.endAngle = parseFloat(groupValues[42]?.[0] || Math.PI * 2);
                        break;

                    case 'LWPOLYLINE':
                    case 'POLYLINE':
                        entity.vertices = [];
                        entity.closed = (parseInt(groupValues[70]?.[0] || 0) & 1) === 1;

                        if (type === 'LWPOLYLINE') {
                            const xVals = groupValues[10] || [];
                            const yVals = groupValues[20] || [];
                            const bulges = groupValues[42] || [];

                            for (let j = 0; j < xVals.length; j++) {
                                entity.vertices.push({
                                    x: parseFloat(xVals[j]),
                                    y: parseFloat(yVals[j]),
                                    bulge: parseFloat(bulges[j] || 0)
                                });
                            }
                        }
                        break;

                    case 'SPLINE':
                        entity.controlPoints = [];
                        entity.degree = parseInt(groupValues[71]?.[0] || 3);

                        const splineX = groupValues[10] || [];
                        const splineY = groupValues[20] || [];

                        for (let j = 0; j < splineX.length; j++) {
                            entity.controlPoints.push({
                                x: parseFloat(splineX[j]),
                                y: parseFloat(splineY[j])
                            });
                        }
                        break;

                    default:
                        return { entity: null, nextIndex: i };
                }

                return { entity, nextIndex: i };
            }
        }

        // ============================================
        // SVG Generator
        // ============================================

        class SvgGenerator {
            constructor(entities) {
                this.entities = entities;
                this.bounds = this.calculateBounds();
            }

            calculateBounds() {
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                const updateBounds = (x, y) => {
                    if (isFinite(x) && isFinite(y)) {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                };

                for (const entity of this.entities) {
                    switch (entity.type) {
                        case 'LINE':
                            updateBounds(entity.start.x, entity.start.y);
                            updateBounds(entity.end.x, entity.end.y);
                            break;
                        case 'CIRCLE':
                            updateBounds(entity.center.x - entity.radius, entity.center.y - entity.radius);
                            updateBounds(entity.center.x + entity.radius, entity.center.y + entity.radius);
                            break;
                        case 'ARC':
                            updateBounds(entity.center.x - entity.radius, entity.center.y - entity.radius);
                            updateBounds(entity.center.x + entity.radius, entity.center.y + entity.radius);
                            break;
                        case 'ELLIPSE':
                            const majorLen = Math.sqrt(entity.majorAxis.x ** 2 + entity.majorAxis.y ** 2);
                            const minorLen = majorLen * entity.ratio;
                            updateBounds(entity.center.x - majorLen, entity.center.y - minorLen);
                            updateBounds(entity.center.x + majorLen, entity.center.y + minorLen);
                            break;
                        case 'LWPOLYLINE':
                        case 'POLYLINE':
                            for (const v of entity.vertices) {
                                updateBounds(v.x, v.y);
                            }
                            break;
                        case 'SPLINE':
                            for (const p of entity.controlPoints) {
                                updateBounds(p.x, p.y);
                            }
                            break;
                    }
                }

                if (!isFinite(minX)) { minX = 0; minY = 0; maxX = 100; maxY = 100; }

                return { minX, minY, maxX, maxY };
            }

            generateSvg(scale = 1) {
                const { minX, minY, maxX, maxY } = this.bounds;
                const width = (maxX - minX) * scale;
                const height = (maxY - minY) * scale;
                const padding = Math.max(width, height) * 0.02;

                let svgContent = '';

                for (const entity of this.entities) {
                    svgContent += this.entityToSvg(entity);
                }

                return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="${minX - padding} ${-(maxY + padding)} ${(maxX - minX) + padding * 2} ${(maxY - minY) + padding * 2}"
     width="${width}mm"
     height="${height}mm">
  <g transform="scale(1, -1)" stroke="#000000" stroke-width="0.5" fill="none">
${svgContent}  </g>
</svg>`;
            }

            entityToSvg(entity) {
                switch (entity.type) {
                    case 'LINE':
                        return `    <line x1="${entity.start.x}" y1="${entity.start.y}" x2="${entity.end.x}" y2="${entity.end.y}"/>\n`;

                    case 'CIRCLE':
                        return `    <circle cx="${entity.center.x}" cy="${entity.center.y}" r="${entity.radius}"/>\n`;

                    case 'ARC':
                        return this.arcToPath(entity);

                    case 'ELLIPSE':
                        return this.ellipseToPath(entity);

                    case 'LWPOLYLINE':
                    case 'POLYLINE':
                        return this.polylineToPath(entity);

                    case 'SPLINE':
                        return this.splineToPath(entity);

                    default:
                        return '';
                }
            }

            arcToPath(entity) {
                const { center, radius, startAngle, endAngle } = entity;
                const startRad = startAngle * Math.PI / 180;
                const endRad = endAngle * Math.PI / 180;

                const x1 = center.x + radius * Math.cos(startRad);
                const y1 = center.y + radius * Math.sin(startRad);
                const x2 = center.x + radius * Math.cos(endRad);
                const y2 = center.y + radius * Math.sin(endRad);

                // Determine arc direction and large arc flag
                let sweepAngle = endAngle - startAngle;
                if (sweepAngle < 0) sweepAngle += 360;
                const largeArc = sweepAngle > 180 ? 1 : 0;

                return `    <path d="M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2}"/>\n`;
            }

            ellipseToPath(entity) {
                const { center, majorAxis, ratio, startAngle, endAngle } = entity;
                const rx = Math.sqrt(majorAxis.x ** 2 + majorAxis.y ** 2);
                const ry = rx * ratio;
                const rotation = Math.atan2(majorAxis.y, majorAxis.x) * 180 / Math.PI;

                // Full ellipse
                if (Math.abs(endAngle - startAngle - Math.PI * 2) < 0.01 || (startAngle === 0 && endAngle === 0)) {
                    return `    <ellipse cx="${center.x}" cy="${center.y}" rx="${rx}" ry="${ry}" transform="rotate(${rotation} ${center.x} ${center.y})"/>\n`;
                }

                // Partial ellipse (arc)
                const x1 = center.x + rx * Math.cos(startAngle);
                const y1 = center.y + ry * Math.sin(startAngle);
                const x2 = center.x + rx * Math.cos(endAngle);
                const y2 = center.y + ry * Math.sin(endAngle);

                let sweepAngle = endAngle - startAngle;
                if (sweepAngle < 0) sweepAngle += Math.PI * 2;
                const largeArc = sweepAngle > Math.PI ? 1 : 0;

                return `    <path d="M ${x1} ${y1} A ${rx} ${ry} ${rotation} ${largeArc} 1 ${x2} ${y2}"/>\n`;
            }

            polylineToPath(entity) {
                if (entity.vertices.length < 2) return '';

                let d = `M ${entity.vertices[0].x} ${entity.vertices[0].y}`;

                for (let i = 0; i < entity.vertices.length - 1; i++) {
                    const v1 = entity.vertices[i];
                    const v2 = entity.vertices[i + 1];

                    if (v1.bulge && v1.bulge !== 0) {
                        // Arc segment
                        const arc = this.bulgeToArc(v1, v2, v1.bulge);
                        d += ` A ${arc.radius} ${arc.radius} 0 ${arc.largeArc} ${arc.sweep} ${v2.x} ${v2.y}`;
                    } else {
                        // Line segment
                        d += ` L ${v2.x} ${v2.y}`;
                    }
                }

                // Handle closed polyline
                if (entity.closed && entity.vertices.length > 2) {
                    const vLast = entity.vertices[entity.vertices.length - 1];
                    const vFirst = entity.vertices[0];

                    if (vLast.bulge && vLast.bulge !== 0) {
                        const arc = this.bulgeToArc(vLast, vFirst, vLast.bulge);
                        d += ` A ${arc.radius} ${arc.radius} 0 ${arc.largeArc} ${arc.sweep} ${vFirst.x} ${vFirst.y}`;
                    } else {
                        d += ' Z';
                    }
                }

                return `    <path d="${d}"/>\n`;
            }

            bulgeToArc(v1, v2, bulge) {
                const dx = v2.x - v1.x;
                const dy = v2.y - v1.y;
                const chord = Math.sqrt(dx * dx + dy * dy);
                const sagitta = Math.abs(bulge) * chord / 2;
                const radius = (chord * chord / 4 + sagitta * sagitta) / (2 * sagitta);

                return {
                    radius,
                    largeArc: Math.abs(bulge) > 1 ? 1 : 0,
                    sweep: bulge > 0 ? 1 : 0
                };
            }

            splineToPath(entity) {
                if (entity.controlPoints.length < 2) return '';

                // Approximate spline with line segments through interpolated points
                const points = this.interpolateSpline(entity.controlPoints, entity.degree);

                let d = `M ${points[0].x} ${points[0].y}`;
                for (let i = 1; i < points.length; i++) {
                    d += ` L ${points[i].x} ${points[i].y}`;
                }

                return `    <path d="${d}"/>\n`;
            }

            interpolateSpline(controlPoints, degree) {
                // Simple Catmull-Rom spline interpolation
                if (controlPoints.length < 2) return controlPoints;

                const result = [];
                const segments = 20; // Points per segment

                for (let i = 0; i < controlPoints.length - 1; i++) {
                    const p0 = controlPoints[Math.max(0, i - 1)];
                    const p1 = controlPoints[i];
                    const p2 = controlPoints[i + 1];
                    const p3 = controlPoints[Math.min(controlPoints.length - 1, i + 2)];

                    for (let t = 0; t < segments; t++) {
                        const s = t / segments;
                        const s2 = s * s;
                        const s3 = s2 * s;

                        const x = 0.5 * ((2 * p1.x) +
                            (-p0.x + p2.x) * s +
                            (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * s2 +
                            (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * s3);

                        const y = 0.5 * ((2 * p1.y) +
                            (-p0.y + p2.y) * s +
                            (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * s2 +
                            (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * s3);

                        result.push({ x, y });
                    }
                }

                // Add final point
                result.push(controlPoints[controlPoints.length - 1]);

                return result;
            }
        }

        // ============================================
        // Main Application
        // ============================================

        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        const unitSelect = document.getElementById('unitSelect');
        const downloadBtn = document.getElementById('downloadBtn');
        const status = document.getElementById('status');
        const previewContainer = document.getElementById('previewContainer');
        const previewArea = document.getElementById('previewArea');
        const previewFilename = document.getElementById('previewFilename');
        const dimensions = document.getElementById('dimensions');

        let currentSvgString = null;
        let currentFilename = '';
        let currentDxfText = null;

        // Event listeners
        dropzone.addEventListener('click', function(e) {
            if (e.target !== fileInput) {
                fileInput.click();
            }
        });

        dropzone.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.add('dragover');
        });

        dropzone.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.remove('dragover');
        });

        dropzone.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', function(e) {
            const files = e.target.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        downloadBtn.addEventListener('click', downloadSvg);

        unitSelect.addEventListener('change', function() {
            if (currentDxfText) {
                processDxf(currentDxfText, currentFilename);
            }
        });

        function showStatus(message, type) {
            status.textContent = message;
            status.className = 'status ' + type;
        }

        function handleFile(file) {
            if (!file.name.toLowerCase().endsWith('.dxf')) {
                showStatus('Please select a DXF file.', 'error');
                return;
            }

            currentFilename = file.name.replace(/\.dxf$/i, '');
            showStatus('Reading file...', 'info');

            const reader = new FileReader();
            reader.onload = function(e) {
                currentDxfText = e.target.result;
                processDxf(currentDxfText, currentFilename);
            };
            reader.onerror = function() {
                showStatus('Error reading file.', 'error');
            };
            reader.readAsText(file);
        }

        function processDxf(dxfText, filename) {
            showStatus('Parsing DXF...', 'info');

            try {
                const parser = new DxfParser();
                const parsed = parser.parse(dxfText);

                if (!parsed.entities || parsed.entities.length === 0) {
                    showStatus('No supported geometry found in DXF file.', 'error');
                    return;
                }

                const generator = new SvgGenerator(parsed.entities);
                const bounds = generator.bounds;
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;

                // Determine scale based on unit selection
                let scale = 1;
                let detectedUnit = 'mm';
                const unitSetting = unitSelect.value;

                if (unitSetting === 'auto') {
                    const maxDim = Math.max(width, height);
                    if (maxDim < 1) {
                        scale = 25.4;
                        detectedUnit = 'inches (converted to mm)';
                    } else if (maxDim > 2000) {
                        scale = 1;
                        detectedUnit = 'mm';
                    } else {
                        scale = 1;
                        detectedUnit = 'mm';
                    }
                } else if (unitSetting === 'in') {
                    scale = 25.4;
                    detectedUnit = 'inches (converted to mm)';
                } else {
                    scale = 1;
                    detectedUnit = 'mm';
                }

                currentSvgString = generator.generateSvg(scale);

                // Calculate final dimensions
                const finalWidth = (width * scale).toFixed(2);
                const finalHeight = (height * scale).toFixed(2);

                // Update UI
                previewArea.innerHTML = currentSvgString;
                previewFilename.textContent = filename + '.dxf';
                dimensions.textContent = `${finalWidth} Ã— ${finalHeight} mm (detected: ${detectedUnit})`;
                previewContainer.classList.add('visible');
                downloadBtn.disabled = false;

                showStatus(`Converted successfully! Found ${parsed.entities.length} entities.`, 'success');

            } catch (error) {
                console.error('Error processing DXF:', error);
                showStatus('Error processing DXF: ' + error.message, 'error');
                downloadBtn.disabled = true;
            }
        }

        function downloadSvg() {
            if (!currentSvgString) return;

            const blob = new Blob([currentSvgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = currentFilename + '.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
