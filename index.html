<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DXF to SVG Converter for Laser Cutting</title>
    <style>
        :root {
            --bg: #f5f5f5;
            --surface: #fff;
            --surface-alt: #fafafa;
            --surface-inset: #f0f0f0;
            --surface-hover: #e0e0e0;
            --border: #ddd;
            --border-light: #eee;
            --border-mid: #ccc;
            --border-input: #d0d0d0;
            --text: #333;
            --text-secondary: #555;
            --text-muted: #666;
            --text-hint: #888;
            --text-faint: #999;
            --accent: #007bff;
            --accent-hover: #0056b3;
            --accent-bg: #f0f7ff;
            --danger: #dc3545;
            --danger-hover: #c82333;
            --status-error-bg: #fee;
            --status-error-text: #c00;
            --status-error-border: #fcc;
            --status-success-bg: #efe;
            --status-success-text: #060;
            --status-success-border: #cfc;
            --status-info-bg: #eef;
            --status-info-text: #006;
            --status-info-border: #ccf;
            --file-item-bg: #fff;
            --file-item-border: #e8e8e8;
            --svg-bg: #fff;
            --svg-shadow: rgba(0,0,0,0.1);
            --svg-stroke: #000000;
            --btn-disabled: #ccc;
            color-scheme: light dark;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #1a1a1a;
                --surface: #2a2a2a;
                --surface-alt: #252525;
                --surface-inset: #333;
                --surface-hover: #444;
                --border: #444;
                --border-light: #383838;
                --border-mid: #555;
                --border-input: #555;
                --text: #e0e0e0;
                --text-secondary: #bbb;
                --text-muted: #aaa;
                --text-hint: #888;
                --text-faint: #777;
                --accent: #4da3ff;
                --accent-hover: #7abbff;
                --accent-bg: #1a2a3a;
                --danger: #e55565;
                --danger-hover: #ff6b7b;
                --status-error-bg: #3a1a1a;
                --status-error-text: #f88;
                --status-error-border: #5a2a2a;
                --status-success-bg: #1a3a1a;
                --status-success-text: #8f8;
                --status-success-border: #2a5a2a;
                --status-info-bg: #1a1a3a;
                --status-info-text: #88f;
                --status-info-border: #2a2a5a;
                --file-item-bg: #333;
                --file-item-border: #444;
                --svg-bg: #1e1e1e;
                --svg-shadow: rgba(0,0,0,0.4);
                --svg-stroke: #d0d0d0;
                --btn-disabled: #555;
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: var(--text);
            margin-bottom: 8px;
            font-size: 1.8rem;
        }

        .subtitle {
            text-align: center;
            color: var(--text-muted);
            margin-bottom: 24px;
            font-size: 0.95rem;
        }

        .dropzone {
            border: 3px dashed var(--border-mid);
            border-radius: 12px;
            padding: 48px 24px;
            text-align: center;
            background: var(--surface);
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 20px;
        }

        .dropzone:hover,
        .dropzone.dragover {
            border-color: var(--accent);
            background: var(--accent-bg);
        }

        .dropzone-text {
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        .dropzone-text strong {
            color: var(--accent);
        }

        .dropzone input[type="file"] {
            display: none;
        }

        .preview-header-units {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .preview-header-units label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        select {
            padding: 8px 12px;
            border: 1px solid var(--border-mid);
            border-radius: 6px;
            font-size: 0.9rem;
            background: var(--surface);
            color: var(--text);
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: var(--accent);
            color: #fff;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--accent-hover);
        }

        .btn-primary:disabled {
            background: var(--btn-disabled);
            cursor: not-allowed;
        }

        .status {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .status.error {
            display: block;
            background: var(--status-error-bg);
            color: var(--status-error-text);
            border: 1px solid var(--status-error-border);
        }

        .status.success {
            display: block;
            background: var(--status-success-bg);
            color: var(--status-success-text);
            border: 1px solid var(--status-success-border);
        }

        .status.info {
            display: block;
            background: var(--status-info-bg);
            color: var(--status-info-text);
            border: 1px solid var(--status-info-border);
        }

        .preview-container {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            display: none;
        }

        .preview-container.visible {
            display: block;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .preview-title {
            font-size: 1rem;
            color: var(--text);
        }

        .dimensions {
            font-size: 0.9rem;
            color: var(--text-muted);
            background: var(--surface-alt);
            padding: 6px 12px;
            border-radius: 4px;
        }

        .preview-area {
            background: var(--surface-alt);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            overflow: hidden;
            position: relative;
            user-select: none;
        }

        .preview-area svg {
            max-width: 100%;
            max-height: 500px;
            background: var(--svg-bg);
            box-shadow: 0 2px 8px var(--svg-shadow);
            color: var(--svg-stroke);
        }

        .filename {
            font-family: monospace;
            background: var(--surface-inset);
            padding: 2px 6px;
            border-radius: 3px;
        }

        .supported-entities {
            margin-top: 24px;
            padding: 16px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .supported-entities strong {
            color: var(--text);
        }

        /* Color selection toolbar */
        .color-toolbar {
            display: none;
            gap: 8px;
            align-items: center;
            padding: 12px 16px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .color-toolbar.visible {
            display: flex;
        }

        .color-toolbar-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-right: 8px;
        }

        .color-swatches {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: var(--text-faint);
        }

        .color-swatch.active {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(0,123,255,0.3);
        }

        .custom-color-input {
            width: 28px;
            height: 28px;
            padding: 0;
            border: 2px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
        }

        .selection-info {
            margin-left: auto;
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .btn-clear-selection {
            padding: 6px 12px;
            font-size: 0.85rem;
            background: var(--surface-inset);
            color: var(--text);
            border: 1px solid var(--border-mid);
        }

        .btn-clear-selection:hover {
            background: var(--surface-hover);
        }

        /* SVG element selection styles */
        .preview-area svg .selectable {
            cursor: pointer;
            transition: filter 0.1s ease;
        }

        .preview-area svg .selectable:hover {
            filter: drop-shadow(0 0 2px #007bff) drop-shadow(0 0 5px rgba(0,123,255,0.6));
        }

        .preview-area svg .selected {
            filter: drop-shadow(0 0 2px #007bff) drop-shadow(0 0 6px #007bff);
        }

        /* Invisible hit area for easier selection */
        .preview-area svg .hit-area {
            stroke: transparent;
            stroke-width: 12;
            fill: none;
            pointer-events: stroke;
            cursor: pointer;
            vector-effect: non-scaling-stroke;
        }

        /* Selection box (rubber band) */
        .selection-box {
            position: absolute;
            border: 2px dashed var(--accent);
            background: rgba(0, 123, 255, 0.1);
            pointer-events: none;
            z-index: 1000;
        }

        .toolbar-help-group {
            position: relative;
        }

        .btn-help-tooltip {
            font-weight: bold;
            min-width: 28px;
            padding: 6px 8px;
            cursor: pointer;
        }

        .help-tooltip-text {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            margin-top: 6px;
            width: 340px;
            padding: 10px 14px;
            background: var(--surface);
            color: var(--text-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.85rem;
            line-height: 1.5;
            z-index: 100;
            box-shadow: 0 4px 12px var(--svg-shadow);
        }

        .toolbar-help-group:hover .help-tooltip-text,
        .toolbar-help-group:focus-within .help-tooltip-text {
            display: block;
        }

        .export-bar {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 16px;
        }

        /* Bed controls */
        .bed-dim-input {
            width: 70px;
            padding: 6px 8px;
            border: 1px solid var(--border-input);
            border-radius: 4px;
            font-size: 13px;
            background: var(--surface);
            color: var(--text);
        }
        .bed-dim-sep {
            font-size: 13px;
            color: var(--text-secondary);
        }
        .tray-rect {
            stroke: #999;
            stroke-dasharray: 8 4;
            fill: none;
            pointer-events: none;
            vector-effect: non-scaling-stroke;
        }

        /* File list */
        .file-list {
            background: var(--surface-alt);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 12px;
        }

        .file-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .file-list-items {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 150px;
            overflow-y: auto;
        }

        .file-list-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: var(--file-item-bg);
            border: 1px solid var(--file-item-border);
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .file-list-item .filename {
            flex: 1;
        }

        .file-list-item .group-checkbox {
            margin: 0;
            cursor: pointer;
        }

        .btn-file-action {
            padding: 3px 8px;
            font-size: 0.8rem;
            background: var(--surface-inset);
            border: 1px solid var(--border-mid);
            border-radius: 3px;
            cursor: pointer;
            color: var(--text);
        }

        .btn-file-action:hover {
            background: var(--surface-hover);
        }

        .btn-remove-file {
            padding: 2px 6px;
            font-size: 0.85rem;
            background: none;
            border: none;
            color: var(--text-faint);
            cursor: pointer;
            font-weight: bold;
        }

        .btn-remove-file:hover {
            color: var(--danger);
        }

        /* Mode toolbar */
        .mode-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            margin-bottom: 6px;
        }

        .toolbar-group {
            display: inline-flex;
            gap: 4px;
            align-items: center;
            border: 1px solid var(--border-mid);
            border-radius: 8px;
            padding: 3px 4px;
            background: var(--surface-alt);
        }

        .btn-mode {
            padding: 6px 14px;
            font-size: 0.85rem;
            background: var(--surface-inset);
            color: var(--text);
            border: 1px solid var(--border-mid);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .btn-mode:hover {
            background: var(--surface-hover);
        }

        .btn-mode.active {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent);
        }

        /* Delete button */
        .btn-danger {
            padding: 6px 12px;
            font-size: 0.85rem;
            background: var(--danger);
            color: #fff;
            border: 1px solid var(--danger);
            border-radius: 6px;
            cursor: pointer;
        }

        .btn-danger:hover {
            background: var(--danger-hover);
        }

        /* Move mode cursors */
        .preview-area.move-mode {
            cursor: grab;
        }

        .preview-area.move-mode.dragging-group {
            cursor: grabbing;
        }

        .preview-area.panning {
            cursor: move !important;
        }

        /* Group highlight */
        .group-highlight {
            pointer-events: none;
            vector-effect: non-scaling-stroke;
        }

        /* Snap indicator */
        .snap-indicator {
            pointer-events: none;
            vector-effect: non-scaling-stroke;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DXF to SVG Converter</h1>
        <p class="subtitle">Convert DXF files to SVG for Glowforge and other laser cutters</p>

        <div class="dropzone" id="dropzone">
            <p class="dropzone-text">
                <strong>Drop DXF files here</strong><br>
                or click to browse (multiple files supported)
            </p>
            <input type="file" id="fileInput" accept=".dxf" multiple>
        </div>

        <div class="status" id="status"></div>

        <div class="preview-container" id="previewContainer">
            <div class="preview-header">
                <span class="preview-title">Preview</span>
                <span class="preview-header-units">
                    <label for="unitSelect">Input units:</label>
                    <select id="unitSelect">
                        <option value="auto">Auto-detect</option>
                        <option value="mm">Millimeters (mm)</option>
                        <option value="in">Inches</option>
                    </select>
                </span>
                <span class="dimensions" id="dimensions"></span>
            </div>

            <div class="file-list" id="fileList">
                <div class="file-list-header">
                    <span>Imported files:</span>
                    <button class="btn btn-file-action" id="groupSelectedBtn" style="display:none;">Group Selected</button>
                    <button class="btn btn-file-action" id="clearAllBtn">Clear All</button>
                </div>
                <div class="file-list-items" id="fileListItems"></div>
            </div>

            <div class="mode-toolbar">
                <span class="toolbar-group">
                    <button class="btn btn-mode" id="undoBtn" disabled title="Undo (Ctrl+Z)">Undo</button>
                    <button class="btn btn-mode" id="redoBtn" disabled title="Redo (Ctrl+Shift+Z)">Redo</button>
                </span>
                <span class="toolbar-group">
                    <button class="btn btn-mode" id="moveModeBtn">Move Mode: OFF</button>
                    <button class="btn btn-mode active" id="snapToggleBtn">Snap: ON</button>
                    <button class="btn btn-mode" id="resetViewBtn">Reset View</button>
                </span>
                <span class="toolbar-group">
                    <button class="btn btn-mode" id="removeDuplicatesBtn">Find Overlaps</button>
                    <select id="dupActionSelect" title="Action for duplicates">
                        <option value="remove">Remove</option>
                        <option value="highlight">Highlight</option>
                    </select>
                    <select id="dupToleranceSelect" title="Duplicate detection tolerance">
                        <option value="0.01">±0.01 (tight)</option>
                        <option value="0.1" selected>±0.1 (default)</option>
                        <option value="0.5">±0.5</option>
                        <option value="1">±1.0</option>
                        <option value="5">±5.0 (loose)</option>
                    </select>
                </span>
                <span class="toolbar-group">
                    <button class="btn btn-mode" id="bedToggleBtn">Bed: OFF</button>
                    <select id="bedPresetSelect" class="bed-control" style="display:none;">
                        <option value="glowforge">Glowforge (19.5″×11″)</option>
                        <option value="custom">Custom</option>
                    </select>
                    <input type="number" id="bedWidthInput" class="bed-control bed-dim-input" style="display:none;" step="any">
                    <span class="bed-control bed-dim-sep" id="bedDimSep" style="display:none;">×</span>
                    <input type="number" id="bedHeightInput" class="bed-control bed-dim-input" style="display:none;" step="any">
                    <label class="bed-control" style="display:none; font-size:0.85rem; color:var(--text-secondary);">Margin:</label>
                    <input type="number" id="autoPlaceMarginInput" class="bed-control bed-dim-input" style="display:none; width:55px;" value="2" min="0" step="any">
                    <button class="btn btn-mode bed-control" id="autoPlaceBtn" style="display:none;">Auto Place</button>
                </span>
                <span class="toolbar-group toolbar-help-group">
                    <button class="btn btn-mode btn-help-tooltip" id="helpTooltipBtn" type="button">?</button>
                    <span class="help-tooltip-text">Click to select, double-click for chain, drag to box-select, Shift to add. Scroll to zoom, Ctrl+drag or middle-click to pan. Toggle Move Mode to drag groups. Delete key to remove selected.</span>
                </span>
            </div>

            <div class="preview-area" id="previewArea"></div>

            <div class="color-toolbar" id="colorToolbar">
                <span class="color-toolbar-label">Set color:</span>
                <div class="color-swatches" id="colorSwatches">
                    <div class="color-swatch" data-color="#000000" style="background: #000000;" title="Black"></div>
                    <div class="color-swatch" data-color="#FF0000" style="background: #FF0000;" title="Red"></div>
                    <div class="color-swatch" data-color="#00FF00" style="background: #00FF00;" title="Green"></div>
                    <div class="color-swatch" data-color="#0000FF" style="background: #0000FF;" title="Blue"></div>
                    <div class="color-swatch" data-color="#FF00FF" style="background: #FF00FF;" title="Magenta"></div>
                    <div class="color-swatch" data-color="#00FFFF" style="background: #00FFFF;" title="Cyan"></div>
                    <div class="color-swatch" data-color="#FFA500" style="background: #FFA500;" title="Orange"></div>
                    <div class="color-swatch" data-color="#800080" style="background: #800080;" title="Purple"></div>
                    <input type="color" class="custom-color-input" id="customColor" value="#000000" title="Custom color">
                </div>
                <span class="selection-info" id="selectionInfo">0 selected</span>
                <button class="btn btn-danger" id="deleteSelectionBtn">Delete Selected</button>
                <button class="btn btn-clear-selection" id="clearSelectionBtn">Clear Selection</button>
            </div>
            <div class="export-bar">
                <button class="btn btn-primary" id="downloadBtn" disabled>Download SVG</button>
                <button class="btn btn-primary" id="downloadDxfBtn" disabled>Download DXF</button>
            </div>
        </div>

        <div class="supported-entities">
            <strong>Supported DXF entities:</strong> LINE, CIRCLE, ELLIPSE, ARC, LWPOLYLINE, POLYLINE, SPLINE<br>
            <strong>Note:</strong> TEXT and DIMENSION entities are not supported. Convert text to paths in your CAD software before exporting.<br>
            <a href="https://github.com/borgel/bad-dxf-svg" style="color: #007bff;">View source on GitHub</a>
        </div>
    </div>

    <script>
        // ============================================
        // Inline DXF Parser - No external dependencies
        // ============================================

        class DxfParser {
            parse(dxfString) {
                const lines = dxfString.split(/\r?\n/);
                const entities = [];
                let i = 0;

                // Find ENTITIES section
                while (i < lines.length) {
                    if (lines[i].trim() === 'ENTITIES') {
                        i++;
                        break;
                    }
                    i++;
                }

                // Parse entities
                while (i < lines.length) {
                    const code = parseInt(lines[i].trim(), 10);
                    const value = lines[i + 1] ? lines[i + 1].trim() : '';

                    if (code === 0) {
                        if (value === 'ENDSEC' || value === 'EOF') break;

                        const entityType = value;
                        i += 2;
                        const result = this.parseEntity(entityType, lines, i);
                        if (result) {
                            i = result.nextIndex;
                            if (result.entity) {
                                entities.push(result.entity);
                            }
                        }
                    } else {
                        i += 2;
                    }
                }

                // Decompose LWPOLYLINE/POLYLINE into individual LINE/ARC segments
                const expanded = [];
                for (const entity of entities) {
                    if (entity.type === 'LWPOLYLINE' || entity.type === 'POLYLINE') {
                        expanded.push(...this.decomposePolyline(entity));
                    } else {
                        expanded.push(entity);
                    }
                }

                return { entities: expanded };
            }

            parseEntity(type, lines, startIndex) {
                const entity = { type };
                let i = startIndex;

                const groupValues = {};

                while (i < lines.length) {
                    const code = parseInt(lines[i].trim(), 10);
                    const value = lines[i + 1] ? lines[i + 1].trim() : '';

                    if (code === 0) {
                        break;
                    }

                    if (!groupValues[code]) {
                        groupValues[code] = [];
                    }
                    groupValues[code].push(value);

                    i += 2;
                }

                switch (type) {
                    case 'LINE':
                        entity.start = {
                            x: parseFloat(groupValues[10]?.[0] || 0),
                            y: parseFloat(groupValues[20]?.[0] || 0)
                        };
                        entity.end = {
                            x: parseFloat(groupValues[11]?.[0] || 0),
                            y: parseFloat(groupValues[21]?.[0] || 0)
                        };
                        break;

                    case 'CIRCLE':
                        entity.center = {
                            x: parseFloat(groupValues[10]?.[0] || 0),
                            y: parseFloat(groupValues[20]?.[0] || 0)
                        };
                        entity.radius = parseFloat(groupValues[40]?.[0] || 0);
                        break;

                    case 'ARC':
                        entity.center = {
                            x: parseFloat(groupValues[10]?.[0] || 0),
                            y: parseFloat(groupValues[20]?.[0] || 0)
                        };
                        entity.radius = parseFloat(groupValues[40]?.[0] || 0);
                        entity.startAngle = parseFloat(groupValues[50]?.[0] || 0);
                        entity.endAngle = parseFloat(groupValues[51]?.[0] || 0);
                        break;

                    case 'ELLIPSE':
                        entity.center = {
                            x: parseFloat(groupValues[10]?.[0] || 0),
                            y: parseFloat(groupValues[20]?.[0] || 0)
                        };
                        entity.majorAxis = {
                            x: parseFloat(groupValues[11]?.[0] || 1),
                            y: parseFloat(groupValues[21]?.[0] || 0)
                        };
                        entity.ratio = parseFloat(groupValues[40]?.[0] || 1);
                        entity.startAngle = parseFloat(groupValues[41]?.[0] || 0);
                        entity.endAngle = parseFloat(groupValues[42]?.[0] || Math.PI * 2);
                        break;

                    case 'LWPOLYLINE':
                    case 'POLYLINE':
                        entity.vertices = [];
                        entity.closed = (parseInt(groupValues[70]?.[0] || 0) & 1) === 1;

                        if (type === 'LWPOLYLINE') {
                            const xVals = groupValues[10] || [];
                            const yVals = groupValues[20] || [];
                            const bulges = groupValues[42] || [];

                            for (let j = 0; j < xVals.length; j++) {
                                entity.vertices.push({
                                    x: parseFloat(xVals[j]),
                                    y: parseFloat(yVals[j]),
                                    bulge: parseFloat(bulges[j] || 0)
                                });
                            }
                        }
                        break;

                    case 'SPLINE':
                        entity.controlPoints = [];
                        entity.knots = [];
                        entity.degree = parseInt(groupValues[71]?.[0] || 3);

                        const splineX = groupValues[10] || [];
                        const splineY = groupValues[20] || [];
                        const knotValues = groupValues[40] || [];

                        for (let j = 0; j < splineX.length; j++) {
                            entity.controlPoints.push({
                                x: parseFloat(splineX[j]),
                                y: parseFloat(splineY[j])
                            });
                        }

                        for (let j = 0; j < knotValues.length; j++) {
                            entity.knots.push(parseFloat(knotValues[j]));
                        }
                        break;

                    default:
                        return { entity: null, nextIndex: i };
                }

                return { entity, nextIndex: i };
            }

            decomposePolyline(entity) {
                const verts = entity.vertices;
                if (verts.length < 2) return [];

                const segments = [];
                const n = verts.length;
                const count = entity.closed ? n : n - 1;

                for (let i = 0; i < count; i++) {
                    const v1 = verts[i];
                    const v2 = verts[(i + 1) % n];

                    // Skip degenerate zero-length segments
                    const dx = v2.x - v1.x;
                    const dy = v2.y - v1.y;
                    if (dx === 0 && dy === 0) continue;

                    if (v1.bulge && v1.bulge !== 0) {
                        segments.push(this.bulgeToArcEntity(v1, v2, v1.bulge));
                    } else {
                        segments.push({
                            type: 'LINE',
                            start: { x: v1.x, y: v1.y },
                            end: { x: v2.x, y: v2.y }
                        });
                    }
                }

                return segments;
            }

            bulgeToArcEntity(v1, v2, bulge) {
                const dx = v2.x - v1.x;
                const dy = v2.y - v1.y;
                const chord = Math.sqrt(dx * dx + dy * dy);
                const sagitta = Math.abs(bulge) * chord / 2;
                const radius = (chord * chord / 4 + sagitta * sagitta) / (2 * sagitta);

                // Center: offset perpendicular from chord midpoint
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;
                const dist = radius - sagitta;
                // Unit perpendicular: for bulge > 0 (CCW), offset left of chord direction
                const perpX = -dy / chord;
                const perpY = dx / chord;
                const sign = bulge > 0 ? 1 : -1;
                const cx = midX + sign * dist * perpX;
                const cy = midY + sign * dist * perpY;

                // Angles from center to endpoints (in degrees, DXF convention)
                let startAngle = Math.atan2(v1.y - cy, v1.x - cx) * 180 / Math.PI;
                let endAngle = Math.atan2(v2.y - cy, v2.x - cx) * 180 / Math.PI;

                // For negative bulge (CW arc), swap start/end to maintain CCW convention
                if (bulge < 0) {
                    const tmp = startAngle;
                    startAngle = endAngle;
                    endAngle = tmp;
                }

                // Normalize angles to [0, 360)
                if (startAngle < 0) startAngle += 360;
                if (endAngle < 0) endAngle += 360;

                return {
                    type: 'ARC',
                    center: { x: cx, y: cy },
                    radius,
                    startAngle,
                    endAngle
                };
            }
        }

        // ============================================
        // SVG Generator (refactored for groups)
        // ============================================

        class SvgGenerator {
            calculateBoundsForEntities(entities, offsetX = 0, offsetY = 0) {
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                const updateBounds = (x, y) => {
                    x += offsetX;
                    y += offsetY;
                    if (isFinite(x) && isFinite(y)) {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                };

                for (const entity of entities) {
                    switch (entity.type) {
                        case 'LINE':
                            updateBounds(entity.start.x, entity.start.y);
                            updateBounds(entity.end.x, entity.end.y);
                            break;
                        case 'CIRCLE':
                            updateBounds(entity.center.x - entity.radius, entity.center.y - entity.radius);
                            updateBounds(entity.center.x + entity.radius, entity.center.y + entity.radius);
                            break;
                        case 'ARC':
                            updateBounds(entity.center.x - entity.radius, entity.center.y - entity.radius);
                            updateBounds(entity.center.x + entity.radius, entity.center.y + entity.radius);
                            break;
                        case 'ELLIPSE': {
                            const majorLen = Math.sqrt(entity.majorAxis.x ** 2 + entity.majorAxis.y ** 2);
                            const minorLen = majorLen * entity.ratio;
                            updateBounds(entity.center.x - majorLen, entity.center.y - minorLen);
                            updateBounds(entity.center.x + majorLen, entity.center.y + minorLen);
                            break;
                        }
                        case 'SPLINE':
                            for (const p of entity.controlPoints) {
                                updateBounds(p.x, p.y);
                            }
                            break;
                    }
                }

                if (!isFinite(minX)) { minX = 0; minY = 0; maxX = 100; maxY = 100; }

                return { minX, minY, maxX, maxY };
            }

            calculateCompositeBounds(groups) {
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                for (const group of groups) {
                    const b = this.calculateBoundsForEntities(group.entities, group.offsetX, group.offsetY);
                    if (isFinite(b.minX)) {
                        minX = Math.min(minX, b.minX);
                        minY = Math.min(minY, b.minY);
                        maxX = Math.max(maxX, b.maxX);
                        maxY = Math.max(maxY, b.maxY);
                    }
                }

                if (!isFinite(minX)) { minX = 0; minY = 0; maxX = 100; maxY = 100; }
                return { minX, minY, maxX, maxY };
            }

            generateCompositeSvg(groups, colorOverrides, scale = 1, forExport = false) {
                const bounds = this.calculateCompositeBounds(groups);
                const { minX, minY, maxX, maxY } = bounds;
                const width = maxX - minX;
                const height = maxY - minY;
                const padding = Math.max(width, height) * 0.02;

                let groupsContent = '';
                for (const group of groups) {
                    const content = this.generateGroupContent(group, colorOverrides, forExport);
                    if (forExport) {
                        groupsContent += `    <g transform="translate(${group.offsetX}, ${group.offsetY})">\n${content}    </g>\n`;
                    } else {
                        groupsContent += `    <g data-group-id="${group.id}" transform="translate(${group.offsetX}, ${group.offsetY})">\n${content}    </g>\n`;
                    }
                }

                const vbX = minX - padding;
                const vbY = -(maxY + padding);
                const vbW = width + padding * 2;
                const vbH = height + padding * 2;

                const xmlDecl = forExport ? '<?xml version="1.0" encoding="UTF-8"?>\n' : '';

                return `${xmlDecl}<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="${vbX} ${vbY} ${vbW} ${vbH}"
     width="${(width * scale).toFixed(2)}mm"
     height="${(height * scale).toFixed(2)}mm">
  <g transform="scale(1, -1)" stroke="${forExport ? '#000000' : 'currentColor'}" stroke-width="0.5" fill="none">
${groupsContent}  </g>
</svg>`;
            }

            generateGroupContent(group, colorOverrides, forExport) {
                let content = '';
                for (let i = 0; i < group.entities.length; i++) {
                    content += this.entityToSvg(group.entities[i], group.id, i, colorOverrides, forExport);
                }
                return content;
            }

            entityToSvg(entity, groupId, entityIndex, colorOverrides, forExport) {
                let extraAttrs = '';
                const colorKey = `${groupId}-${entityIndex}`;
                if (colorOverrides && colorOverrides.has(colorKey)) {
                    extraAttrs += ` stroke="${colorOverrides.get(colorKey)}"`;
                }
                if (!forExport) {
                    extraAttrs += ` data-element-id="${entityIndex}"`;
                }

                switch (entity.type) {
                    case 'LINE':
                        return this.lineToSvg(entity, extraAttrs, forExport);
                    case 'CIRCLE':
                        return this.circleToSvg(entity, extraAttrs, forExport);
                    case 'ARC':
                        return this.arcToSvg(entity, extraAttrs, forExport);
                    case 'ELLIPSE':
                        return this.ellipseToSvg(entity, extraAttrs, forExport);
                    case 'SPLINE':
                        return this.splineToSvg(entity, extraAttrs, forExport);
                    default:
                        return '';
                }
            }

            lineToSvg(entity, extraAttrs, forExport) {
                const ep = forExport ? '' : ` data-start-x="${entity.start.x}" data-start-y="${entity.start.y}" data-end-x="${entity.end.x}" data-end-y="${entity.end.y}"`;
                return `      <line x1="${entity.start.x}" y1="${entity.start.y}" x2="${entity.end.x}" y2="${entity.end.y}"${ep}${extraAttrs}/>\n`;
            }

            circleToSvg(entity, extraAttrs, forExport) {
                const ep = forExport ? '' : ' data-closed="true"';
                return `      <circle cx="${entity.center.x}" cy="${entity.center.y}" r="${entity.radius}"${ep}${extraAttrs}/>\n`;
            }

            arcToSvg(entity, extraAttrs, forExport) {
                const { center, radius, startAngle, endAngle } = entity;
                const startRad = startAngle * Math.PI / 180;
                const endRad = endAngle * Math.PI / 180;

                const x1 = center.x + radius * Math.cos(startRad);
                const y1 = center.y + radius * Math.sin(startRad);
                const x2 = center.x + radius * Math.cos(endRad);
                const y2 = center.y + radius * Math.sin(endRad);

                let sweepAngle = endAngle - startAngle;
                if (sweepAngle < 0) sweepAngle += 360;
                const largeArc = sweepAngle > 180 ? 1 : 0;

                const ep = forExport ? '' : ` data-start-x="${x1}" data-start-y="${y1}" data-end-x="${x2}" data-end-y="${y2}"`;
                return `      <path d="M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2}"${ep}${extraAttrs}/>\n`;
            }

            ellipseToSvg(entity, extraAttrs, forExport) {
                const { center, majorAxis, ratio, startAngle, endAngle } = entity;
                const rx = Math.sqrt(majorAxis.x ** 2 + majorAxis.y ** 2);
                const ry = rx * ratio;
                const rotation = Math.atan2(majorAxis.y, majorAxis.x) * 180 / Math.PI;

                if (Math.abs(endAngle - startAngle - Math.PI * 2) < 0.01 || (startAngle === 0 && endAngle === 0)) {
                    const ep = forExport ? '' : ' data-closed="true"';
                    return `      <ellipse cx="${center.x}" cy="${center.y}" rx="${rx}" ry="${ry}" transform="rotate(${rotation} ${center.x} ${center.y})"${ep}${extraAttrs}/>\n`;
                }

                const x1 = center.x + rx * Math.cos(startAngle);
                const y1 = center.y + ry * Math.sin(startAngle);
                const x2 = center.x + rx * Math.cos(endAngle);
                const y2 = center.y + ry * Math.sin(endAngle);

                let sweepAngle = endAngle - startAngle;
                if (sweepAngle < 0) sweepAngle += Math.PI * 2;
                const largeArc = sweepAngle > Math.PI ? 1 : 0;

                const ep = forExport ? '' : ` data-start-x="${x1}" data-start-y="${y1}" data-end-x="${x2}" data-end-y="${y2}"`;
                return `      <path d="M ${x1} ${y1} A ${rx} ${ry} ${rotation} ${largeArc} 1 ${x2} ${y2}"${ep}${extraAttrs}/>\n`;
            }

            splineToSvg(entity, extraAttrs, forExport) {
                if (entity.controlPoints.length < 2) return '';

                const points = this.interpolateSpline(entity.controlPoints, entity.degree);

                const startX = points[0].x;
                const startY = points[0].y;
                const endX = points[points.length - 1].x;
                const endY = points[points.length - 1].y;

                let d = `M ${startX} ${startY}`;
                for (let i = 1; i < points.length; i++) {
                    d += ` L ${points[i].x} ${points[i].y}`;
                }

                const ep = forExport ? '' : ` data-start-x="${startX}" data-start-y="${startY}" data-end-x="${endX}" data-end-y="${endY}"`;
                return `      <path d="${d}"${ep}${extraAttrs}/>\n`;
            }

            interpolateSpline(controlPoints, degree) {
                if (controlPoints.length < 2) return controlPoints;

                const result = [];
                const segments = 20;

                for (let i = 0; i < controlPoints.length - 1; i++) {
                    const p0 = controlPoints[Math.max(0, i - 1)];
                    const p1 = controlPoints[i];
                    const p2 = controlPoints[i + 1];
                    const p3 = controlPoints[Math.min(controlPoints.length - 1, i + 2)];

                    for (let t = 0; t < segments; t++) {
                        const s = t / segments;
                        const s2 = s * s;
                        const s3 = s2 * s;

                        const x = 0.5 * ((2 * p1.x) +
                            (-p0.x + p2.x) * s +
                            (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * s2 +
                            (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * s3);

                        const y = 0.5 * ((2 * p1.y) +
                            (-p0.y + p2.y) * s +
                            (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * s2 +
                            (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * s3);

                        result.push({ x, y });
                    }
                }

                result.push(controlPoints[controlPoints.length - 1]);
                return result;
            }
        }

        // ============================================
        // DXF Writer
        // ============================================

        class DxfWriter {
            constructor(groups, colorOverrides) {
                this.groups = groups;
                this.colorOverrides = colorOverrides;
                this.output = '';
            }

            generate() {
                this.writeHeader();
                this.writeEntitiesSection();
                this.output += '  0\nEOF\n';
                return this.output;
            }

            writeCode(code, value) {
                const codeStr = code.toString();
                const padding = codeStr.length >= 3 ? '' : codeStr.length === 2 ? ' ' : '  ';
                this.output += padding + codeStr + '\n' + value + '\n';
            }

            writeHeader() {
                this.writeCode(0, 'SECTION');
                this.writeCode(2, 'HEADER');
                this.writeCode(9, '$ACADVER');
                this.writeCode(1, 'AC1009');
                this.writeCode(9, '$INSUNITS');
                this.writeCode(70, '4');
                this.writeCode(0, 'ENDSEC');
            }

            writeEntitiesSection() {
                this.writeCode(0, 'SECTION');
                this.writeCode(2, 'ENTITIES');

                for (const group of this.groups) {
                    for (let i = 0; i < group.entities.length; i++) {
                        const entity = group.entities[i];
                        const colorKey = `${group.id}-${i}`;
                        const color = this.colorOverrides.get(colorKey);
                        const aci = color ? this.hexToAci(color) : null;
                        this.writeEntity(entity, group.offsetX, group.offsetY, aci);
                    }
                }

                this.writeCode(0, 'ENDSEC');
            }

            writeEntity(entity, ox, oy, aci) {
                switch (entity.type) {
                    case 'LINE':
                        this.writeCode(0, 'LINE');
                        this.writeCode(8, '0');
                        if (aci !== null) this.writeCode(62, aci);
                        this.writeCode(10, (entity.start.x + ox).toFixed(6));
                        this.writeCode(20, (entity.start.y + oy).toFixed(6));
                        this.writeCode(11, (entity.end.x + ox).toFixed(6));
                        this.writeCode(21, (entity.end.y + oy).toFixed(6));
                        break;

                    case 'CIRCLE':
                        this.writeCode(0, 'CIRCLE');
                        this.writeCode(8, '0');
                        if (aci !== null) this.writeCode(62, aci);
                        this.writeCode(10, (entity.center.x + ox).toFixed(6));
                        this.writeCode(20, (entity.center.y + oy).toFixed(6));
                        this.writeCode(40, entity.radius.toFixed(6));
                        break;

                    case 'ARC':
                        this.writeCode(0, 'ARC');
                        this.writeCode(8, '0');
                        if (aci !== null) this.writeCode(62, aci);
                        this.writeCode(10, (entity.center.x + ox).toFixed(6));
                        this.writeCode(20, (entity.center.y + oy).toFixed(6));
                        this.writeCode(40, entity.radius.toFixed(6));
                        this.writeCode(50, entity.startAngle.toFixed(6));
                        this.writeCode(51, entity.endAngle.toFixed(6));
                        break;

                    case 'ELLIPSE':
                        this.writeCode(0, 'ELLIPSE');
                        this.writeCode(8, '0');
                        if (aci !== null) this.writeCode(62, aci);
                        this.writeCode(10, (entity.center.x + ox).toFixed(6));
                        this.writeCode(20, (entity.center.y + oy).toFixed(6));
                        this.writeCode(30, '0.0');
                        this.writeCode(11, entity.majorAxis.x.toFixed(6));
                        this.writeCode(21, entity.majorAxis.y.toFixed(6));
                        this.writeCode(31, '0.0');
                        this.writeCode(40, entity.ratio.toFixed(6));
                        this.writeCode(41, entity.startAngle.toFixed(6));
                        this.writeCode(42, entity.endAngle.toFixed(6));
                        break;

                    case 'SPLINE':
                        this.writeCode(0, 'SPLINE');
                        this.writeCode(8, '0');
                        if (aci !== null) this.writeCode(62, aci);
                        this.writeCode(70, '8');
                        const deg = entity.degree || 3;
                        this.writeCode(71, deg);
                        const n = entity.controlPoints.length;
                        let knots = entity.knots;
                        if (!knots || knots.length === 0) {
                            const numKnots = n + deg + 1;
                            knots = [];
                            for (let k = 0; k < numKnots; k++) {
                                if (k <= deg) knots.push(0.0);
                                else if (k >= n) knots.push(1.0);
                                else knots.push((k - deg) / (n - deg));
                            }
                        }
                        this.writeCode(72, knots.length);
                        this.writeCode(73, n);
                        for (const k of knots) {
                            this.writeCode(40, k.toFixed(6));
                        }
                        for (const pt of entity.controlPoints) {
                            this.writeCode(10, (pt.x + ox).toFixed(6));
                            this.writeCode(20, (pt.y + oy).toFixed(6));
                            this.writeCode(30, '0.0');
                        }
                        break;
                }
            }

            hexToAci(hex) {
                const map = {
                    '#000000': 7, '#FF0000': 1, '#00FF00': 3, '#0000FF': 5,
                    '#FF00FF': 6, '#00FFFF': 4, '#FFA500': 30, '#800080': 218
                };
                return map[hex.toUpperCase()] || 7;
            }
        }

        // ============================================
        // Main Application
        // ============================================

        // --- State ---
        let importedGroups = [];
        let groupIdCounter = 0;
        let colorOverrides = new Map();
        let selectedElements = new Set();

        // Undo/Redo
        const undoStack = [];
        const redoStack = [];
        const MAX_UNDO = 50;

        function saveUndoState() {
            undoStack.push({
                groups: JSON.parse(JSON.stringify(importedGroups)),
                colorOverrides: new Map(colorOverrides),
                groupIdCounter: groupIdCounter
            });
            if (undoStack.length > MAX_UNDO) undoStack.shift();
            redoStack.length = 0;
            updateUndoRedoButtons();
        }

        function restoreState(state) {
            importedGroups = state.groups;
            colorOverrides = new Map(state.colorOverrides);
            groupIdCounter = state.groupIdCounter;
            selectedElements.clear();
            selectedGroupId = null;
            clearGroupHighlight();
            rebuildCanvas(true);
        }

        function undo() {
            if (undoStack.length === 0) return;
            redoStack.push({
                groups: JSON.parse(JSON.stringify(importedGroups)),
                colorOverrides: new Map(colorOverrides),
                groupIdCounter: groupIdCounter
            });
            restoreState(undoStack.pop());
            updateUndoRedoButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;
            undoStack.push({
                groups: JSON.parse(JSON.stringify(importedGroups)),
                colorOverrides: new Map(colorOverrides),
                groupIdCounter: groupIdCounter
            });
            restoreState(redoStack.pop());
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn) undoBtn.disabled = undoStack.length === 0;
            if (redoBtn) redoBtn.disabled = redoStack.length === 0;
        }

        // Viewport
        let viewCenterX = 0, viewCenterY = 0;
        let viewZoom = 1;
        let baseViewBox = null;
        let baseBounds = null;

        // Bed/tray
        let bedEnabled = false;
        let bedWidth = 495.3;   // mm default (Glowforge, landscape)
        let bedHeight = 279.4;

        // Move mode
        let moveMode = false;
        let selectedGroupId = null;

        // Interaction state
        let isPanning = false;
        let panStartScreenX = 0, panStartScreenY = 0;

        let isDragSelecting = false;
        let didDragSelect = false;
        let dragSelectStartX = 0, dragSelectStartY = 0;
        let selectionBoxEl = null;
        let dragSelectStartTarget = null;

        let isMovingGroup = false;
        let didStartMove = false;
        let moveLastScreenX = 0, moveLastScreenY = 0;

        // Snap
        let snapEnabled = true;
        let otherGroupEndpoints = [];
        let dragGroupEndpoints = [];
        const SNAP_TOLERANCE = 5.0;
        const CONNECTION_TOLERANCE = 0.5;
        let duplicateTolerance = 0.1;

        // Element interaction map
        let elementMap = new Map();

        // --- DOM References ---
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        const unitSelect = document.getElementById('unitSelect');
        const downloadBtn = document.getElementById('downloadBtn');
        const downloadDxfBtn = document.getElementById('downloadDxfBtn');
        const removeDuplicatesBtn = document.getElementById('removeDuplicatesBtn');
        const dupToleranceSelect = document.getElementById('dupToleranceSelect');
        const status = document.getElementById('status');
        const previewContainer = document.getElementById('previewContainer');
        const previewArea = document.getElementById('previewArea');
        const dimensions = document.getElementById('dimensions');
        const colorToolbar = document.getElementById('colorToolbar');
        const colorSwatches = document.getElementById('colorSwatches');
        const customColor = document.getElementById('customColor');
        const selectionInfo = document.getElementById('selectionInfo');
        const clearSelectionBtn = document.getElementById('clearSelectionBtn');
        const deleteSelectionBtn = document.getElementById('deleteSelectionBtn');
        const fileListItems = document.getElementById('fileListItems');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const groupSelectedBtn = document.getElementById('groupSelectedBtn');
        const moveModeBtn = document.getElementById('moveModeBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const bedToggleBtn = document.getElementById('bedToggleBtn');
        const bedPresetSelect = document.getElementById('bedPresetSelect');
        const bedWidthInput = document.getElementById('bedWidthInput');
        const bedHeightInput = document.getElementById('bedHeightInput');
        const autoPlaceBtn = document.getElementById('autoPlaceBtn');
        const autoPlaceMarginInput = document.getElementById('autoPlaceMarginInput');

        // --- Utility Functions ---

        function getEntityEndpoints(entity) {
            switch (entity.type) {
                case 'LINE':
                    return [
                        { x: entity.start.x, y: entity.start.y },
                        { x: entity.end.x, y: entity.end.y }
                    ];
                case 'ARC': {
                    const startRad = entity.startAngle * Math.PI / 180;
                    const endRad = entity.endAngle * Math.PI / 180;
                    return [
                        { x: entity.center.x + entity.radius * Math.cos(startRad), y: entity.center.y + entity.radius * Math.sin(startRad) },
                        { x: entity.center.x + entity.radius * Math.cos(endRad), y: entity.center.y + entity.radius * Math.sin(endRad) }
                    ];
                }
                case 'SPLINE':
                    if (entity.controlPoints.length < 2) return [];
                    return [
                        { x: entity.controlPoints[0].x, y: entity.controlPoints[0].y },
                        { x: entity.controlPoints[entity.controlPoints.length - 1].x, y: entity.controlPoints[entity.controlPoints.length - 1].y }
                    ];
                default:
                    return [];
            }
        }

        function pointsAreClose(p1, p2, tolerance) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.sqrt(dx * dx + dy * dy) <= tolerance;
        }

        function getElementEndpoints(el) {
            if (el.dataset.closed === 'true') return null;
            const startX = parseFloat(el.dataset.startX);
            const startY = parseFloat(el.dataset.startY);
            const endX = parseFloat(el.dataset.endX);
            const endY = parseFloat(el.dataset.endY);
            if (isNaN(startX) || isNaN(startY) || isNaN(endX) || isNaN(endY)) return null;
            return { start: { x: startX, y: startY }, end: { x: endX, y: endY } };
        }

        function findConnectedElements(startElement, allElements) {
            const connected = new Set([startElement]);
            const toProcess = [startElement];

            while (toProcess.length > 0) {
                const current = toProcess.pop();
                const currentEndpoints = getElementEndpoints(current);
                if (!currentEndpoints) continue;

                allElements.forEach(el => {
                    if (connected.has(el)) return;
                    const elEndpoints = getElementEndpoints(el);
                    if (!elEndpoints) return;

                    const isConnected =
                        pointsAreClose(currentEndpoints.start, elEndpoints.start, CONNECTION_TOLERANCE) ||
                        pointsAreClose(currentEndpoints.start, elEndpoints.end, CONNECTION_TOLERANCE) ||
                        pointsAreClose(currentEndpoints.end, elEndpoints.start, CONNECTION_TOLERANCE) ||
                        pointsAreClose(currentEndpoints.end, elEndpoints.end, CONNECTION_TOLERANCE);

                    if (isConnected) {
                        connected.add(el);
                        toProcess.push(el);
                    }
                });
            }

            return connected;
        }

        function findGroupIdFromElement(el) {
            let current = el;
            while (current && current !== previewArea) {
                if (current.dataset && current.dataset.groupId !== undefined) {
                    return parseInt(current.dataset.groupId);
                }
                current = current.parentElement;
            }
            return null;
        }

        function findGroupById(id) {
            return importedGroups.find(g => g.id === id);
        }

        function applyOffsetToEntities(entities, dx, dy) {
            for (const e of entities) {
                switch (e.type) {
                    case 'LINE':
                        e.start.x += dx; e.start.y += dy;
                        e.end.x += dx; e.end.y += dy;
                        break;
                    case 'CIRCLE':
                    case 'ARC':
                        e.center.x += dx; e.center.y += dy;
                        break;
                    case 'ELLIPSE':
                        e.center.x += dx; e.center.y += dy;
                        break;
                    case 'SPLINE':
                        if (e.controlPoints) {
                            for (const p of e.controlPoints) { p.x += dx; p.y += dy; }
                        }
                        break;
                }
            }
        }

        function groupSelectedFiles(groupIds) {
            if (groupIds.length < 2) return;
            saveUndoState();

            const mergedEntities = [];
            const subGroups = [];
            const newId = groupIdCounter++;
            const newOverrides = new Map();

            // Build merged entity list with baked-in offsets
            for (const gid of groupIds) {
                const group = findGroupById(gid);
                if (!group) continue;

                const startIndex = mergedEntities.length;
                const cloned = JSON.parse(JSON.stringify(group.entities));
                applyOffsetToEntities(cloned, group.offsetX, group.offsetY);

                // Remap color overrides
                for (let i = 0; i < cloned.length; i++) {
                    const oldKey = `${gid}-${i}`;
                    if (colorOverrides.has(oldKey)) {
                        newOverrides.set(`${newId}-${startIndex + i}`, colorOverrides.get(oldKey));
                        colorOverrides.delete(oldKey);
                    }
                }

                mergedEntities.push(...cloned);
                subGroups.push({ filename: group.filename, startIndex, count: cloned.length });
            }

            // Remove source groups
            importedGroups = importedGroups.filter(g => !groupIds.includes(g.id));

            // Clean up any remaining overrides for removed groups
            for (const gid of groupIds) {
                for (const [key] of colorOverrides) {
                    if (key.startsWith(`${gid}-`)) colorOverrides.delete(key);
                }
            }

            // Add remapped overrides
            for (const [k, v] of newOverrides) colorOverrides.set(k, v);

            const filenames = subGroups.map(sg => sg.filename);
            importedGroups.push({
                id: newId,
                filename: filenames.join(' + '),
                entities: mergedEntities,
                offsetX: 0,
                offsetY: 0,
                subGroups: subGroups
            });

            rebuildCanvas(false);
            showStatus(`Grouped ${subGroups.length} files into one.`, 'success');
        }

        function ungroupFile(groupId) {
            const group = findGroupById(groupId);
            if (!group || !group.subGroups) return;
            saveUndoState();

            const restoredGroups = [];

            for (const sg of group.subGroups) {
                const cloned = JSON.parse(JSON.stringify(group.entities.slice(sg.startIndex, sg.startIndex + sg.count)));
                const newId = groupIdCounter++;

                // Remap color overrides
                for (let i = 0; i < cloned.length; i++) {
                    const oldKey = `${groupId}-${sg.startIndex + i}`;
                    if (colorOverrides.has(oldKey)) {
                        colorOverrides.set(`${newId}-${i}`, colorOverrides.get(oldKey));
                        colorOverrides.delete(oldKey);
                    }
                }

                restoredGroups.push({
                    id: newId,
                    filename: sg.filename,
                    entities: cloned,
                    offsetX: 0,
                    offsetY: 0
                });
            }

            // Remove merged group and add restored ones
            importedGroups = importedGroups.filter(g => g.id !== groupId);
            importedGroups.push(...restoredGroups);

            rebuildCanvas(false);
            showStatus(`Ungrouped into ${restoredGroups.length} files.`, 'success');
        }

        function updateGroupButton() {
            const checked = document.querySelectorAll('.group-checkbox:checked').length;
            groupSelectedBtn.style.display = checked >= 2 ? '' : 'none';
        }

        function getScale() {
            const unitSetting = unitSelect.value;
            if (unitSetting === 'in') return 25.4;
            if (unitSetting === 'mm') return 1;
            // Auto-detect
            if (importedGroups.length === 0) return 1;
            const gen = new SvgGenerator();
            const bounds = gen.calculateCompositeBounds(importedGroups);
            const maxDim = Math.max(bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);
            if (maxDim < 1) return 25.4;
            return 1;
        }

        // --- MaxRects Bin Packing ---

        function rectsOverlap(a, b) {
            return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
        }

        function rectContains(outer, inner) {
            return inner.x >= outer.x && inner.y >= outer.y &&
                   inner.x + inner.w <= outer.x + outer.w &&
                   inner.y + inner.h <= outer.y + outer.h;
        }

        function maxRectsPack(binW, binH, rects) {
            // Sort by max area descending (largest first)
            const indices = rects.map((_, i) => i);
            indices.sort((a, b) => {
                const aMax = Math.max(...rects[a].sizes.map(s => s.w * s.h));
                const bMax = Math.max(...rects[b].sizes.map(s => s.w * s.h));
                return bMax - aMax;
            });

            let freeRects = [{ x: 0, y: 0, w: binW, h: binH }];
            const placements = new Array(rects.length).fill(null);

            for (const idx of indices) {
                const rect = rects[idx];
                let bestScore = Infinity;
                let bestX = 0, bestY = 0, bestSizeIdx = -1, bestFreeIdx = -1;

                // BSSF: Best Short Side Fit
                for (let si = 0; si < rect.sizes.length; si++) {
                    const s = rect.sizes[si];
                    for (let fi = 0; fi < freeRects.length; fi++) {
                        const f = freeRects[fi];
                        if (s.w <= f.w && s.h <= f.h) {
                            const leftoverShort = Math.min(f.w - s.w, f.h - s.h);
                            if (leftoverShort < bestScore) {
                                bestScore = leftoverShort;
                                bestX = f.x;
                                bestY = f.y;
                                bestSizeIdx = si;
                                bestFreeIdx = fi;
                            }
                        }
                    }
                }

                if (bestSizeIdx === -1) continue; // doesn't fit

                const chosen = rect.sizes[bestSizeIdx];
                const placed = { x: bestX, y: bestY, w: chosen.w, h: chosen.h, angle: chosen.angle };
                placements[idx] = placed;

                // Split free rectangles
                const newFree = [];
                for (const f of freeRects) {
                    if (!rectsOverlap(f, placed)) {
                        newFree.push(f);
                        continue;
                    }
                    // Generate up to 4 splits
                    if (placed.x > f.x)
                        newFree.push({ x: f.x, y: f.y, w: placed.x - f.x, h: f.h });
                    if (placed.x + placed.w < f.x + f.w)
                        newFree.push({ x: placed.x + placed.w, y: f.y, w: (f.x + f.w) - (placed.x + placed.w), h: f.h });
                    if (placed.y > f.y)
                        newFree.push({ x: f.x, y: f.y, w: f.w, h: placed.y - f.y });
                    if (placed.y + placed.h < f.y + f.h)
                        newFree.push({ x: f.x, y: placed.y + placed.h, w: f.w, h: (f.y + f.h) - (placed.y + placed.h) });
                }

                // Prune contained rectangles
                freeRects = [];
                for (let i = 0; i < newFree.length; i++) {
                    let contained = false;
                    for (let j = 0; j < newFree.length; j++) {
                        if (i !== j && rectContains(newFree[j], newFree[i])) {
                            contained = true;
                            break;
                        }
                    }
                    if (!contained) freeRects.push(newFree[i]);
                }
            }

            return placements;
        }

        // --- Entity Rotation ---

        function rotateEntities(entities, angleDeg) {
            if (angleDeg === 0) return;
            const angleRad = angleDeg * Math.PI / 180;
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);

            // Calculate local bbox center
            const gen = new SvgGenerator();
            const bounds = gen.calculateBoundsForEntities(entities);
            const cx = (bounds.minX + bounds.maxX) / 2;
            const cy = (bounds.minY + bounds.maxY) / 2;

            function rotPt(x, y) {
                return {
                    x: cx + (x - cx) * cos + (y - cy) * sin,
                    y: cy - (x - cx) * sin + (y - cy) * cos
                };
            }

            for (const e of entities) {
                switch (e.type) {
                    case 'LINE': {
                        const s = rotPt(e.start.x, e.start.y);
                        const en = rotPt(e.end.x, e.end.y);
                        e.start.x = s.x; e.start.y = s.y;
                        e.end.x = en.x; e.end.y = en.y;
                        break;
                    }
                    case 'CIRCLE': {
                        const c = rotPt(e.center.x, e.center.y);
                        e.center.x = c.x; e.center.y = c.y;
                        break;
                    }
                    case 'ARC': {
                        const c = rotPt(e.center.x, e.center.y);
                        e.center.x = c.x; e.center.y = c.y;
                        e.startAngle -= angleDeg;
                        e.endAngle -= angleDeg;
                        break;
                    }
                    case 'ELLIPSE': {
                        const c = rotPt(e.center.x, e.center.y);
                        e.center.x = c.x; e.center.y = c.y;
                        const ma = rotPt(e.center.x + e.majorAxis.x, e.center.y + e.majorAxis.y);
                        // Recalculate using the already-rotated center
                        const oldMaX = e.majorAxis.x, oldMaY = e.majorAxis.y;
                        e.majorAxis.x = oldMaX * cos + oldMaY * sin;
                        e.majorAxis.y = -oldMaX * sin + oldMaY * cos;
                        e.startAngle -= angleRad;
                        e.endAngle -= angleRad;
                        break;
                    }
                    case 'LWPOLYLINE':
                    case 'POLYLINE':
                        for (const v of e.vertices) {
                            const r = rotPt(v.x, v.y);
                            v.x = r.x; v.y = r.y;
                        }
                        break;
                    case 'SPLINE':
                        for (const p of e.controlPoints) {
                            const r = rotPt(p.x, p.y);
                            p.x = r.x; p.y = r.y;
                        }
                        break;
                }
            }
        }

        // --- Compute rotated bounding box without mutating ---

        function computeRotatedBounds(entities, angleDeg, offsetX, offsetY) {
            if (angleDeg === 0) {
                const gen = new SvgGenerator();
                return gen.calculateBoundsForEntities(entities, offsetX, offsetY);
            }
            const angleRad = angleDeg * Math.PI / 180;
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);

            const gen = new SvgGenerator();
            const bounds = gen.calculateBoundsForEntities(entities);
            const cx = (bounds.minX + bounds.maxX) / 2;
            const cy = (bounds.minY + bounds.maxY) / 2;

            function rotPt(x, y) {
                return {
                    x: cx + (x - cx) * cos + (y - cy) * sin,
                    y: cy - (x - cx) * sin + (y - cy) * cos
                };
            }

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            function update(x, y) {
                x += offsetX; y += offsetY;
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
            }

            for (const e of entities) {
                switch (e.type) {
                    case 'LINE': {
                        const s = rotPt(e.start.x, e.start.y);
                        const en = rotPt(e.end.x, e.end.y);
                        update(s.x, s.y); update(en.x, en.y);
                        break;
                    }
                    case 'CIRCLE': {
                        const c = rotPt(e.center.x, e.center.y);
                        update(c.x - e.radius, c.y - e.radius);
                        update(c.x + e.radius, c.y + e.radius);
                        break;
                    }
                    case 'ARC': {
                        const c = rotPt(e.center.x, e.center.y);
                        update(c.x - e.radius, c.y - e.radius);
                        update(c.x + e.radius, c.y + e.radius);
                        break;
                    }
                    case 'ELLIPSE': {
                        const c = rotPt(e.center.x, e.center.y);
                        const majorLen = Math.sqrt(e.majorAxis.x ** 2 + e.majorAxis.y ** 2);
                        const minorLen = majorLen * e.ratio;
                        const maxDim = Math.max(majorLen, minorLen);
                        update(c.x - maxDim, c.y - maxDim);
                        update(c.x + maxDim, c.y + maxDim);
                        break;
                    }
                    case 'LWPOLYLINE':
                    case 'POLYLINE':
                        for (const v of e.vertices) {
                            const r = rotPt(v.x, v.y);
                            update(r.x, r.y);
                        }
                        break;
                    case 'SPLINE':
                        for (const p of e.controlPoints) {
                            const r = rotPt(p.x, p.y);
                            update(r.x, r.y);
                        }
                        break;
                }
            }
            if (!isFinite(minX)) return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
            return { minX, minY, maxX, maxY };
        }

        // --- Auto Place Orchestration ---

        function autoPlace() {
            if (!bedEnabled) {
                showStatus('Enable bed first to auto-place groups.', 'error');
                return;
            }
            if (importedGroups.length === 0) {
                showStatus('No groups to place.', 'error');
                return;
            }

            saveUndoState();

            const margin = parseFloat(autoPlaceMarginInput.value) || 0;
            const angles = [0, 45, 90, 135];

            // Build rects with candidate sizes for each group
            const rects = importedGroups.map((group, gi) => {
                const sizes = [];
                for (const angle of angles) {
                    const b = computeRotatedBounds(group.entities, angle, 0, 0);
                    const w = (b.maxX - b.minX) + margin * 2;
                    const h = (b.maxY - b.minY) + margin * 2;
                    sizes.push({ w, h, angle });
                }
                return { sizes, groupIndex: gi };
            });

            const placements = maxRectsPack(bedWidth, bedHeight, rects);

            let placedCount = 0;
            for (let i = 0; i < placements.length; i++) {
                const p = placements[i];
                if (!p) continue;
                placedCount++;
                const group = importedGroups[i];

                // Apply rotation if non-zero
                if (p.angle !== 0) {
                    rotateEntities(group.entities, p.angle);
                }

                // Recalc local bounds after rotation
                const gen = new SvgGenerator();
                const b = gen.calculateBoundsForEntities(group.entities);

                // Place so that local bbox starts at p.x + margin, p.y + margin
                group.offsetX = p.x + margin - b.minX;
                group.offsetY = p.y + margin - b.minY;
            }

            rebuildCanvas(true);

            if (placedCount === importedGroups.length) {
                showStatus(`Auto-placed all ${placedCount} group(s) in bed.`, 'success');
            } else {
                showStatus(`Placed ${placedCount}/${importedGroups.length} group(s). ${importedGroups.length - placedCount} did not fit.`, 'error');
            }
        }

        function showStatus(message, type) {
            status.textContent = message;
            status.className = 'status ' + type;
        }

        // --- Core Functions ---

        function rebuildCanvas(resetView = true, suppressStatus = false) {
            selectedElements.clear();
            updateSelectionInfo();
            elementMap.clear();

            if (importedGroups.length === 0) {
                previewContainer.classList.remove('visible');
                downloadBtn.disabled = true;
                downloadDxfBtn.disabled = true;
                previewArea.innerHTML = '';
                baseViewBox = null;
                baseBounds = null;
                status.className = 'status';
                return;
            }

            const generator = new SvgGenerator();
            const bounds = generator.calculateCompositeBounds(importedGroups);

            if (bedEnabled) {
                bounds.minX = Math.min(bounds.minX, 0);
                bounds.minY = Math.min(bounds.minY, 0);
                bounds.maxX = Math.max(bounds.maxX, bedWidth);
                bounds.maxY = Math.max(bounds.maxY, bedHeight);
            }

            baseBounds = bounds;

            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const padding = Math.max(width, height) * 0.02;

            const svgVbX = bounds.minX - padding;
            const svgVbY = -(bounds.maxY + padding);
            const svgVbW = width + padding * 2;
            const svgVbH = height + padding * 2;
            baseViewBox = { x: svgVbX, y: svgVbY, w: svgVbW, h: svgVbH };

            const scale = getScale();
            const svgString = generator.generateCompositeSvg(importedGroups, colorOverrides, scale, false);
            previewArea.innerHTML = svgString;

            if (bedEnabled) {
                const svg = previewArea.querySelector('svg');
                const outerG = svg.querySelector('g');
                const ns = 'http://www.w3.org/2000/svg';
                const rect = document.createElementNS(ns, 'rect');
                rect.setAttribute('x', 0);
                rect.setAttribute('y', 0);
                rect.setAttribute('width', bedWidth);
                rect.setAttribute('height', bedHeight);
                rect.setAttribute('class', 'tray-rect');
                rect.setAttribute('stroke', '#999');
                rect.setAttribute('stroke-dasharray', '8 4');
                rect.setAttribute('stroke-width', '0.5');
                rect.setAttribute('fill', 'none');
                rect.setAttribute('pointer-events', 'none');
                rect.setAttribute('vector-effect', 'non-scaling-stroke');
                outerG.insertBefore(rect, outerG.firstChild);
            }

            setupSvgInteraction();

            if (resetView) {
                viewCenterX = svgVbX + svgVbW / 2;
                viewCenterY = svgVbY + svgVbH / 2;
                viewZoom = 1;
            }
            updateViewBox();

            updateFileList();
            updateDimensionsDisplay();

            previewContainer.classList.add('visible');
            downloadBtn.disabled = false;
            downloadDxfBtn.disabled = false;
            colorToolbar.classList.add('visible');

            if (moveMode && selectedGroupId !== null) {
                showGroupHighlight(selectedGroupId);
            }

            if (moveMode) {
                previewArea.classList.add('move-mode');
            }

            if (!suppressStatus) {
                const totalEntities = importedGroups.reduce((sum, g) => sum + g.entities.length, 0);
                showStatus(`${importedGroups.length} file(s) loaded, ${totalEntities} total entities.`, 'success');
            }
        }

        function updateViewBox() {
            const svg = previewArea.querySelector('svg');
            if (!svg || !baseViewBox) return;

            const w = baseViewBox.w / viewZoom;
            const h = baseViewBox.h / viewZoom;
            svg.setAttribute('viewBox', `${viewCenterX - w / 2} ${viewCenterY - h / 2} ${w} ${h}`);
        }

        function updateDimensionsDisplay() {
            if (!baseBounds) return;
            const scale = getScale();
            const width = baseBounds.maxX - baseBounds.minX;
            const height = baseBounds.maxY - baseBounds.minY;
            const finalWidth = (width * scale).toFixed(2);
            const finalHeight = (height * scale).toFixed(2);
            const unitSetting = unitSelect.value;
            let detectedUnit = 'mm';
            if (unitSetting === 'in' || (unitSetting === 'auto' && scale === 25.4)) {
                detectedUnit = 'inches (converted to mm)';
            }
            dimensions.textContent = `${finalWidth} x ${finalHeight} mm (${detectedUnit})`;
        }

        function updateFileList() {
            fileListItems.innerHTML = '';
            for (const group of importedGroups) {
                const item = document.createElement('div');
                item.className = 'file-list-item';
                const displayName = group.subGroups ? group.filename : group.filename + '.dxf';
                const ungroupBtn = group.subGroups
                    ? `<button class="btn-file-action" data-action="ungroup" data-group-id="${group.id}">Ungroup</button>`
                    : '';
                item.innerHTML = `
                    <input type="checkbox" class="group-checkbox" data-group-id="${group.id}">
                    <span class="filename">${displayName}</span>
                    <button class="btn-file-action" data-action="select" data-group-id="${group.id}">Select</button>
                    ${ungroupBtn}
                    <button class="btn-remove-file" data-action="remove" data-group-id="${group.id}" title="Remove">&times;</button>
                `;
                fileListItems.appendChild(item);
            }
            updateGroupButton();
        }

        function setupSvgInteraction() {
            const svgElement = previewArea.querySelector('svg');
            if (!svgElement) return;

            elementMap.clear();

            const geometryElements = svgElement.querySelectorAll('line, circle, ellipse, path, polyline, polygon, rect:not(.group-highlight)');

            geometryElements.forEach(el => {
                if (el.dataset.elementId === undefined) return;
                el.classList.add('selectable');

                const hitArea = el.cloneNode(true);
                hitArea.classList.remove('selectable');
                hitArea.classList.add('hit-area');
                hitArea.removeAttribute('data-element-id');
                hitArea.dataset.forElement = el.dataset.elementId;

                el.parentNode.insertBefore(hitArea, el);
                elementMap.set(hitArea, el);
            });
        }

        function showGroupHighlight(groupId) {
            clearGroupHighlight();
            const svg = previewArea.querySelector('svg');
            if (!svg) return;

            const groupG = svg.querySelector(`g[data-group-id="${groupId}"]`);
            if (!groupG) return;

            const bbox = groupG.getBBox();
            const pad = 2;

            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', bbox.x - pad);
            rect.setAttribute('y', bbox.y - pad);
            rect.setAttribute('width', bbox.width + pad * 2);
            rect.setAttribute('height', bbox.height + pad * 2);
            rect.setAttribute('class', 'group-highlight');
            rect.setAttribute('stroke', '#007bff');
            rect.setAttribute('stroke-width', '2');
            rect.setAttribute('stroke-dasharray', '6,4');
            rect.setAttribute('fill', 'none');
            rect.setAttribute('pointer-events', 'none');
            rect.setAttribute('vector-effect', 'non-scaling-stroke');

            groupG.appendChild(rect);
        }

        function clearGroupHighlight() {
            const svg = previewArea.querySelector('svg');
            if (!svg) return;
            svg.querySelectorAll('.group-highlight').forEach(el => el.remove());
        }

        // --- Selection Functions ---

        function selectElement(el, shiftKey) {
            if (shiftKey) {
                if (selectedElements.has(el)) {
                    el.classList.remove('selected');
                    selectedElements.delete(el);
                } else {
                    el.classList.add('selected');
                    selectedElements.add(el);
                }
            } else {
                selectedElements.forEach(selected => selected.classList.remove('selected'));
                selectedElements.clear();
                el.classList.add('selected');
                selectedElements.add(el);
            }
            updateSelectionInfo();
        }

        function selectConnectedChain(el, shiftKey) {
            const svgElement = previewArea.querySelector('svg');
            if (!svgElement) return;
            const allSelectables = Array.from(svgElement.querySelectorAll('.selectable'));
            const connected = findConnectedElements(el, allSelectables);

            if (!shiftKey) {
                selectedElements.forEach(selected => selected.classList.remove('selected'));
                selectedElements.clear();
            }

            connected.forEach(connectedEl => {
                connectedEl.classList.add('selected');
                selectedElements.add(connectedEl);
            });

            updateSelectionInfo();
        }

        function clearSelection() {
            selectedElements.forEach(el => el.classList.remove('selected'));
            selectedElements.clear();
            updateSelectionInfo();
        }

        function updateSelectionInfo() {
            const count = selectedElements.size;
            selectionInfo.textContent = count === 0 ? '0 selected' :
                count === 1 ? '1 element selected' : `${count} elements selected`;
        }

        function applyColorToSelection(color) {
            if (selectedElements.size === 0) return;
            saveUndoState();

            selectedElements.forEach(el => {
                el.setAttribute('stroke', color);
                // Also store in colorOverrides for export
                const groupId = findGroupIdFromElement(el);
                const elementId = el.dataset.elementId;
                if (groupId !== null && elementId !== undefined) {
                    colorOverrides.set(`${groupId}-${elementId}`, color);
                }
            });

            updateSelectionInfo();
        }

        // --- Snap Functions ---

        function precomputeSnapPoints(dragGroupId) {
            otherGroupEndpoints = [];
            dragGroupEndpoints = [];

            for (const group of importedGroups) {
                if (group.id === dragGroupId) {
                    for (const entity of group.entities) {
                        const pts = getEntityEndpoints(entity);
                        for (const pt of pts) {
                            dragGroupEndpoints.push({ x: pt.x, y: pt.y });
                        }
                    }
                } else {
                    for (const entity of group.entities) {
                        const pts = getEntityEndpoints(entity);
                        for (const pt of pts) {
                            otherGroupEndpoints.push({
                                x: pt.x + group.offsetX,
                                y: pt.y + group.offsetY
                            });
                        }
                    }
                }
            }

            if (bedEnabled) {
                const bedPoints = [
                    {x: 0, y: 0}, {x: bedWidth, y: 0},
                    {x: 0, y: bedHeight}, {x: bedWidth, y: bedHeight},
                    {x: bedWidth / 2, y: 0}, {x: bedWidth / 2, y: bedHeight},
                    {x: 0, y: bedHeight / 2}, {x: bedWidth, y: bedHeight / 2}
                ];
                otherGroupEndpoints.push(...bedPoints);
            }
        }

        function findSnapPoint(proposedOffsetX, proposedOffsetY) {
            let bestDist = SNAP_TOLERANCE;
            let snapDelta = null;
            let snapPoint = null;

            for (const dPt of dragGroupEndpoints) {
                const absX = dPt.x + proposedOffsetX;
                const absY = dPt.y + proposedOffsetY;

                for (const oPt of otherGroupEndpoints) {
                    const dx = oPt.x - absX;
                    const dy = oPt.y - absY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < bestDist) {
                        bestDist = dist;
                        snapDelta = { x: dx, y: dy };
                        snapPoint = { x: oPt.x, y: oPt.y };
                    }
                }
            }

            return { snapDelta, snapPoint };
        }

        function showSnapIndicator(point) {
            clearSnapIndicators();
            const svg = previewArea.querySelector('svg');
            if (!svg) return;

            const outerG = svg.querySelector('g');
            if (!outerG) return;

            const size = 3;
            const ns = 'http://www.w3.org/2000/svg';

            // Horizontal line
            const h = document.createElementNS(ns, 'line');
            h.setAttribute('x1', point.x - size);
            h.setAttribute('y1', point.y);
            h.setAttribute('x2', point.x + size);
            h.setAttribute('y2', point.y);
            h.setAttribute('stroke', '#00cc00');
            h.setAttribute('stroke-width', '2');
            h.setAttribute('class', 'snap-indicator');
            h.setAttribute('vector-effect', 'non-scaling-stroke');

            // Vertical line
            const v = document.createElementNS(ns, 'line');
            v.setAttribute('x1', point.x);
            v.setAttribute('y1', point.y - size);
            v.setAttribute('x2', point.x);
            v.setAttribute('y2', point.y + size);
            v.setAttribute('stroke', '#00cc00');
            v.setAttribute('stroke-width', '2');
            v.setAttribute('class', 'snap-indicator');
            v.setAttribute('vector-effect', 'non-scaling-stroke');

            outerG.appendChild(h);
            outerG.appendChild(v);
        }

        function clearSnapIndicators() {
            const svg = previewArea.querySelector('svg');
            if (!svg) return;
            svg.querySelectorAll('.snap-indicator').forEach(el => el.remove());
        }

        // --- Action Functions ---

        function handleFiles(files) {
            const validFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.dxf'));
            if (validFiles.length === 0) {
                showStatus('Please select DXF file(s).', 'error');
                return;
            }

            showStatus('Reading files...', 'info');

            const readPromises = validFiles.map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve({ name: file.name, content: e.target.result });
                    reader.onerror = () => reject(new Error(`Failed to read ${file.name}`));
                    reader.readAsText(file);
                });
            });

            Promise.all(readPromises).then(results => {
                const parser = new DxfParser();
                const generator = new SvgGenerator();
                let addedCount = 0;
                let undoSaved = false;

                for (const { name, content } of results) {
                    try {
                        const parsed = parser.parse(content);
                        if (!parsed.entities || parsed.entities.length === 0) {
                            continue;
                        }

                        const filename = name.replace(/\.dxf$/i, '');

                        let offsetX = 0, offsetY = 0;
                        if (importedGroups.length > 0) {
                            const bounds = generator.calculateCompositeBounds(importedGroups);
                            const newBounds = generator.calculateBoundsForEntities(parsed.entities);
                            offsetX = bounds.maxX + 10 - newBounds.minX;
                        }

                        if (!undoSaved) {
                            saveUndoState();
                            undoSaved = true;
                        }
                        importedGroups.push({
                            id: groupIdCounter++,
                            filename: filename,
                            entities: parsed.entities,
                            offsetX: offsetX,
                            offsetY: offsetY
                        });
                        addedCount++;
                    } catch (err) {
                        showStatus(`Error parsing ${name}: ${err.message}`, 'error');
                    }
                }

                if (addedCount > 0) {
                    rebuildCanvas(true);
                }
            }).catch(err => {
                showStatus('Error reading files: ' + err.message, 'error');
            });
        }

        function deleteSelection() {
            if (selectedElements.size === 0) return;
            saveUndoState();

            // Collect which entities to delete: map of groupId -> Set of entityIndex
            const toDelete = new Map();

            selectedElements.forEach(el => {
                const groupId = findGroupIdFromElement(el);
                const elementId = parseInt(el.dataset.elementId);
                if (groupId !== null && !isNaN(elementId)) {
                    if (!toDelete.has(groupId)) {
                        toDelete.set(groupId, new Set());
                    }
                    toDelete.get(groupId).add(elementId);
                }
            });

            let deletedCount = 0;

            // Process deletions (iterate in reverse to preserve indices)
            for (const [groupId, entityIndices] of toDelete) {
                const group = findGroupById(groupId);
                if (!group) continue;

                // Remove entities in reverse index order
                const sortedIndices = Array.from(entityIndices).sort((a, b) => b - a);
                for (const idx of sortedIndices) {
                    group.entities.splice(idx, 1);
                    colorOverrides.delete(`${groupId}-${idx}`);
                    deletedCount++;
                }

                // Invalidate sub-group metadata since indices are now stale
                delete group.subGroups;

                // Rebuild colorOverrides keys for remaining entities in this group
                const newOverrides = new Map();
                for (const [key, value] of colorOverrides) {
                    const [gid, eidStr] = key.split('-');
                    if (parseInt(gid) === groupId) {
                        // This entity's index may have shifted
                        // We need to recalculate
                    } else {
                        newOverrides.set(key, value);
                    }
                }
                // Re-add the remaining entries for this group
                // Since we deleted indices, the remaining entities shifted
                // We need to rebuild based on new positions
                // Simplest: clear all overrides for this group and re-apply visible colors
                // Actually, after splice the indices shifted. Let's rebuild properly.
            }

            // Rebuild all colorOverrides from scratch based on DOM state before rebuild
            // Actually, simpler approach: just rebuild colorOverrides for affected groups
            // Since indices shifted, we need to recapture. Let's just clear overrides for
            // affected groups - the user will need to recolor. This is acceptable.
            for (const groupId of toDelete.keys()) {
                // Remove all overrides for this group
                for (const [key] of colorOverrides) {
                    if (key.startsWith(`${groupId}-`)) {
                        colorOverrides.delete(key);
                    }
                }
            }

            // Remove empty groups
            importedGroups = importedGroups.filter(g => g.entities.length > 0);

            rebuildCanvas(false, true);
            showStatus(`Deleted ${deletedCount} element(s).`, 'success');
        }

        function removeDuplicates() {
            if (importedGroups.length === 0) return;

            const totalBefore = importedGroups.reduce((sum, g) => sum + g.entities.length, 0);

            // Build a flat list of all entities with absolute coordinates info
            const allEntities = [];
            for (const group of importedGroups) {
                for (let i = 0; i < group.entities.length; i++) {
                    allEntities.push({
                        entity: group.entities[i],
                        groupId: group.id,
                        entityIndex: i,
                        ox: group.offsetX,
                        oy: group.offsetY
                    });
                }
            }

            // Find duplicates
            const toRemove = new Set(); // indices in allEntities
            for (let i = 0; i < allEntities.length; i++) {
                if (toRemove.has(i)) continue;
                for (let j = i + 1; j < allEntities.length; j++) {
                    if (toRemove.has(j)) continue;
                    if (entitiesAreDuplicates(allEntities[i], allEntities[j])) {
                        toRemove.add(j);
                    }
                }
            }

            if (toRemove.size === 0) {
                showStatus(`No duplicates found at ±${duplicateTolerance} tolerance (checked ${totalBefore} entities across ${importedGroups.length} file(s)).`, 'info');
                return;
            }

            const action = document.getElementById('dupActionSelect').value;

            saveUndoState();

            // Count duplicates by type and by file for feedback
            const dupByType = {};
            const dupByGroup = {};
            for (const idx of toRemove) {
                const entry = allEntities[idx];
                const t = entry.entity.type;
                dupByType[t] = (dupByType[t] || 0) + 1;
                const group = findGroupById(entry.groupId);
                const fname = group ? group.filename + '.dxf' : 'unknown';
                dupByGroup[fname] = (dupByGroup[fname] || 0) + 1;
            }

            const typeBreakdown = Object.entries(dupByType)
                .map(([type, count]) => `${count} ${type}`)
                .join(', ');
            const fileBreakdown = Object.entries(dupByGroup)
                .map(([fname, count]) => `${count} from ${fname}`)
                .join(', ');

            if (action === 'highlight') {
                // Set color of duplicate entities to highlight color
                const highlightColor = '#FF0000';
                for (const idx of toRemove) {
                    const entry = allEntities[idx];
                    colorOverrides.set(`${entry.groupId}-${entry.entityIndex}`, highlightColor);
                }
                rebuildCanvas(false, true);
                showStatus(`Highlighted ${toRemove.size} duplicate(s) in red: ${typeBreakdown} (${fileBreakdown}).`, 'success');
            } else {
                // Collect removals by group
                const groupRemovals = new Map();
                for (const idx of toRemove) {
                    const entry = allEntities[idx];
                    if (!groupRemovals.has(entry.groupId)) {
                        groupRemovals.set(entry.groupId, new Set());
                    }
                    groupRemovals.get(entry.groupId).add(entry.entityIndex);
                }

                // Remove entities
                let removedCount = 0;
                for (const [groupId, indices] of groupRemovals) {
                    const group = findGroupById(groupId);
                    if (!group) continue;

                    const sortedIndices = Array.from(indices).sort((a, b) => b - a);
                    for (const idx of sortedIndices) {
                        group.entities.splice(idx, 1);
                        removedCount++;
                    }

                    // Clear color overrides for this group (indices shifted)
                    for (const [key] of colorOverrides) {
                        if (key.startsWith(`${groupId}-`)) {
                            colorOverrides.delete(key);
                        }
                    }
                }

                // Remove empty groups
                importedGroups = importedGroups.filter(g => g.entities.length > 0);
                const totalAfter = importedGroups.reduce((sum, g) => sum + g.entities.length, 0);

                rebuildCanvas(false, true);
                showStatus(`Removed ${removedCount} duplicate(s): ${typeBreakdown} (${fileBreakdown}). ${totalBefore} → ${totalAfter} entities.`, 'success');
            }
        }

        function entitiesAreDuplicates(a, b) {
            const e1 = a.entity, e2 = b.entity;
            const ox1 = a.ox, oy1 = a.oy, ox2 = b.ox, oy2 = b.oy;

            if (e1.type !== e2.type) return false;
            const TOL = duplicateTolerance;

            function ptEq(x1, y1, x2, y2) {
                return Math.abs(x1 - x2) < TOL && Math.abs(y1 - y2) < TOL;
            }

            function valEq(a, b) {
                return Math.abs(a - b) < TOL;
            }

            switch (e1.type) {
                case 'LINE':
                    return (ptEq(e1.start.x + ox1, e1.start.y + oy1, e2.start.x + ox2, e2.start.y + oy2) &&
                            ptEq(e1.end.x + ox1, e1.end.y + oy1, e2.end.x + ox2, e2.end.y + oy2)) ||
                           (ptEq(e1.start.x + ox1, e1.start.y + oy1, e2.end.x + ox2, e2.end.y + oy2) &&
                            ptEq(e1.end.x + ox1, e1.end.y + oy1, e2.start.x + ox2, e2.start.y + oy2));

                case 'CIRCLE':
                    return ptEq(e1.center.x + ox1, e1.center.y + oy1, e2.center.x + ox2, e2.center.y + oy2) &&
                           valEq(e1.radius, e2.radius);

                case 'ARC':
                    return ptEq(e1.center.x + ox1, e1.center.y + oy1, e2.center.x + ox2, e2.center.y + oy2) &&
                           valEq(e1.radius, e2.radius) &&
                           valEq(e1.startAngle, e2.startAngle) &&
                           valEq(e1.endAngle, e2.endAngle);

                case 'ELLIPSE':
                    return ptEq(e1.center.x + ox1, e1.center.y + oy1, e2.center.x + ox2, e2.center.y + oy2) &&
                           ptEq(e1.majorAxis.x, e1.majorAxis.y, e2.majorAxis.x, e2.majorAxis.y) &&
                           valEq(e1.ratio, e2.ratio) &&
                           valEq(e1.startAngle, e2.startAngle) &&
                           valEq(e1.endAngle, e2.endAngle);

                case 'SPLINE': {
                    if (e1.controlPoints.length !== e2.controlPoints.length) return false;
                    const m = e1.controlPoints.length;
                    let fwd = true;
                    for (let i = 0; i < m; i++) {
                        if (!ptEq(e1.controlPoints[i].x + ox1, e1.controlPoints[i].y + oy1,
                                   e2.controlPoints[i].x + ox2, e2.controlPoints[i].y + oy2)) {
                            fwd = false;
                            break;
                        }
                    }
                    return fwd;
                }

                default:
                    return false;
            }
        }

        function downloadSvg() {
            if (importedGroups.length === 0) return;
            const generator = new SvgGenerator();
            const scale = getScale();
            const svgString = generator.generateCompositeSvg(importedGroups, colorOverrides, scale, true);

            const filename = importedGroups.length === 1 ? importedGroups[0].filename : 'combined';
            const blob = new Blob([svgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename + '.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function downloadDxf() {
            if (importedGroups.length === 0) return;
            const writer = new DxfWriter(importedGroups, colorOverrides);
            const dxfString = writer.generate();

            const filename = importedGroups.length === 1 ? importedGroups[0].filename : 'combined';
            const blob = new Blob([dxfString], { type: 'application/dxf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename + '.dxf';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- Event Handlers ---

        function handleWheel(e) {
            e.preventDefault();
            const svg = previewArea.querySelector('svg');
            if (!svg || !baseViewBox) return;

            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(20, viewZoom * zoomFactor));

            // Get cursor position as fraction of SVG element
            const rect = svg.getBoundingClientRect();
            const fracX = (e.clientX - rect.left) / rect.width;
            const fracY = (e.clientY - rect.top) / rect.height;

            // Current view dimensions
            const w = baseViewBox.w / viewZoom;
            const h = baseViewBox.h / viewZoom;

            // Cursor position in SVG viewBox space
            const cursorX = (viewCenterX - w / 2) + fracX * w;
            const cursorY = (viewCenterY - h / 2) + fracY * h;

            // New view dimensions
            const newW = baseViewBox.w / newZoom;
            const newH = baseViewBox.h / newZoom;

            // Adjust center to keep cursor at same screen position
            viewCenterX = cursorX + newW * (0.5 - fracX);
            viewCenterY = cursorY + newH * (0.5 - fracY);
            viewZoom = newZoom;

            updateViewBox();
        }

        function handleMouseDown(e) {
            // Middle button or Ctrl+left button (when not in move mode) → pan
            if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
                isPanning = true;
                panStartScreenX = e.clientX;
                panStartScreenY = e.clientY;
                previewArea.classList.add('panning');
                e.preventDefault();
                return;
            }

            if (e.button !== 0) return;

            // Move mode: group interaction
            if (moveMode) {
                let targetElement = e.target;
                if (targetElement.classList.contains('hit-area')) {
                    targetElement = elementMap.get(targetElement) || targetElement;
                }

                const clickedGroupId = findGroupIdFromElement(targetElement);

                if (clickedGroupId !== null) {
                    selectedGroupId = clickedGroupId;
                    showGroupHighlight(selectedGroupId);
                    isMovingGroup = true;
                    didStartMove = false;
                    moveLastScreenX = e.clientX;
                    moveLastScreenY = e.clientY;
                    precomputeSnapPoints(selectedGroupId);
                } else {
                    selectedGroupId = null;
                    clearGroupHighlight();
                }
                e.preventDefault();
                return;
            }

            // Normal selection mode: start potential drag-select
            const rect = previewArea.getBoundingClientRect();
            dragSelectStartX = e.clientX - rect.left;
            dragSelectStartY = e.clientY - rect.top;
            dragSelectStartTarget = e.target;
            isDragSelecting = true;
            didDragSelect = false;

            selectionBoxEl = document.createElement('div');
            selectionBoxEl.className = 'selection-box';
            selectionBoxEl.style.left = dragSelectStartX + 'px';
            selectionBoxEl.style.top = dragSelectStartY + 'px';
            selectionBoxEl.style.width = '0px';
            selectionBoxEl.style.height = '0px';
            selectionBoxEl.style.display = 'none';
            previewArea.appendChild(selectionBoxEl);

            e.preventDefault();
        }

        function handleMouseMove(e) {
            if (isPanning) {
                const svg = previewArea.querySelector('svg');
                if (!svg || !baseViewBox) return;

                const dx = e.clientX - panStartScreenX;
                const dy = e.clientY - panStartScreenY;
                panStartScreenX = e.clientX;
                panStartScreenY = e.clientY;

                const rect = svg.getBoundingClientRect();
                const w = baseViewBox.w / viewZoom;
                const h = baseViewBox.h / viewZoom;

                viewCenterX -= dx * (w / rect.width);
                viewCenterY -= dy * (h / rect.height);
                updateViewBox();
                return;
            }

            if (isMovingGroup) {
                const dx = e.clientX - moveLastScreenX;
                const dy = e.clientY - moveLastScreenY;

                if (!didStartMove && (Math.abs(dx) > 3 || Math.abs(dy) > 3)) {
                    saveUndoState();
                    didStartMove = true;
                    previewArea.classList.add('dragging-group');
                }

                if (didStartMove) {
                    moveLastScreenX = e.clientX;
                    moveLastScreenY = e.clientY;

                    const svg = previewArea.querySelector('svg');
                    if (!svg || !baseViewBox) return;

                    const rect = svg.getBoundingClientRect();
                    const w = baseViewBox.w / viewZoom;
                    const h = baseViewBox.h / viewZoom;

                    // Convert screen pixels to DXF coordinates
                    const dxfDeltaX = dx * (w / rect.width);
                    const dxfDeltaY = -(dy * (h / rect.height));

                    const group = findGroupById(selectedGroupId);
                    if (!group) return;

                    group.offsetX += dxfDeltaX;
                    group.offsetY += dxfDeltaY;

                    // Check for snap
                    if (snapEnabled) {
                        const snap = findSnapPoint(group.offsetX, group.offsetY);
                        if (snap.snapDelta) {
                            group.offsetX += snap.snapDelta.x;
                            group.offsetY += snap.snapDelta.y;
                            showSnapIndicator(snap.snapPoint);
                        } else {
                            clearSnapIndicators();
                        }
                    }

                    // Update the group's transform directly (no full rebuild)
                    const groupG = svg.querySelector(`g[data-group-id="${selectedGroupId}"]`);
                    if (groupG) {
                        groupG.setAttribute('transform', `translate(${group.offsetX}, ${group.offsetY})`);
                    }

                    // Update group highlight
                    showGroupHighlight(selectedGroupId);
                }
                return;
            }

            if (isDragSelecting && selectionBoxEl) {
                const rect = previewArea.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;

                const width = Math.abs(currentX - dragSelectStartX);
                const height = Math.abs(currentY - dragSelectStartY);

                if (width > 5 && height > 5) {
                    didDragSelect = true;
                    selectionBoxEl.style.display = 'block';

                    const left = Math.min(dragSelectStartX, currentX);
                    const top = Math.min(dragSelectStartY, currentY);

                    selectionBoxEl.style.left = left + 'px';
                    selectionBoxEl.style.top = top + 'px';
                    selectionBoxEl.style.width = width + 'px';
                    selectionBoxEl.style.height = height + 'px';
                }
            }
        }

        function handleMouseUp(e) {
            if (isPanning) {
                isPanning = false;
                previewArea.classList.remove('panning');
                return;
            }

            if (isMovingGroup) {
                isMovingGroup = false;
                previewArea.classList.remove('dragging-group');
                clearSnapIndicators();

                if (didStartMove) {
                    // Rebuild to recompute bounds, but preserve view
                    rebuildCanvas(false);
                    // Re-show group highlight after rebuild
                    if (selectedGroupId !== null) {
                        showGroupHighlight(selectedGroupId);
                    }
                }
                didStartMove = false;
                return;
            }

            if (isDragSelecting) {
                const svgElement = previewArea.querySelector('svg');

                if (didDragSelect && selectionBoxEl && svgElement) {
                    const boxRect = selectionBoxEl.getBoundingClientRect();

                    if (!e.shiftKey) {
                        selectedElements.forEach(selected => selected.classList.remove('selected'));
                        selectedElements.clear();
                    }

                    const allSelectables = svgElement.querySelectorAll('.selectable');
                    allSelectables.forEach(el => {
                        const elRect = el.getBoundingClientRect();
                        if (elRect.left < boxRect.right &&
                            elRect.right > boxRect.left &&
                            elRect.top < boxRect.bottom &&
                            elRect.bottom > boxRect.top) {
                            el.classList.add('selected');
                            selectedElements.add(el);
                        }
                    });

                    updateSelectionInfo();
                } else if (!didDragSelect) {
                    // It was a click
                    const target = dragSelectStartTarget;

                    if (target && target.classList.contains('selectable')) {
                        selectElement(target, e.shiftKey);
                    } else if (target && target.classList.contains('hit-area')) {
                        const el = elementMap.get(target);
                        if (el) selectElement(el, e.shiftKey);
                    } else {
                        // Clicked on background
                        if (!e.shiftKey) {
                            clearSelection();
                        }
                    }
                }

                if (selectionBoxEl) {
                    selectionBoxEl.remove();
                    selectionBoxEl = null;
                }
                isDragSelecting = false;
                didDragSelect = false;
                dragSelectStartTarget = null;
            }
        }

        function handleDblClick(e) {
            if (moveMode) return;

            let targetElement = null;
            if (e.target.classList.contains('selectable')) {
                targetElement = e.target;
            } else if (e.target.classList.contains('hit-area')) {
                targetElement = elementMap.get(e.target);
            }

            if (targetElement) {
                e.preventDefault();
                e.stopPropagation();
                selectConnectedChain(targetElement, e.shiftKey);
            }
        }

        function handleKeyDown(e) {
            if ((e.ctrlKey || e.metaKey) && !e.altKey) {
                if (e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                    return;
                }
                if ((e.key === 'z' && e.shiftKey) || e.key === 'y') {
                    e.preventDefault();
                    redo();
                    return;
                }
            }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedElements.size > 0) {
                    e.preventDefault();
                    deleteSelection();
                }
            }
        }

        // --- Event Listener Setup (attached once) ---

        // Dropzone
        dropzone.addEventListener('click', function(e) {
            if (e.target !== fileInput) {
                fileInput.click();
            }
        });

        dropzone.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.add('dragover');
        });

        dropzone.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.remove('dragover');
        });

        dropzone.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFiles(files);
            }
        });

        fileInput.addEventListener('change', function(e) {
            const files = e.target.files;
            if (files.length > 0) {
                handleFiles(files);
            }
            // Reset so the same file(s) can be re-imported
            fileInput.value = '';
        });

        // Controls
        downloadBtn.addEventListener('click', downloadSvg);
        downloadDxfBtn.addEventListener('click', downloadDxf);
        removeDuplicatesBtn.addEventListener('click', removeDuplicates);
        dupToleranceSelect.addEventListener('change', function() {
            duplicateTolerance = parseFloat(dupToleranceSelect.value);
        });

        unitSelect.addEventListener('change', function() {
            if (importedGroups.length > 0) {
                rebuildCanvas(false);
            }
        });

        // Bed controls
        bedToggleBtn.addEventListener('click', function() {
            bedEnabled = !bedEnabled;
            bedToggleBtn.textContent = bedEnabled ? 'Bed: ON' : 'Bed: OFF';
            bedToggleBtn.classList.toggle('active', bedEnabled);
            document.querySelectorAll('.bed-control').forEach(el => {
                el.style.display = bedEnabled ? '' : 'none';
            });
            if (bedEnabled) {
                bedWidthInput.value = bedWidth;
                bedHeightInput.value = bedHeight;
            }
            if (importedGroups.length > 0) {
                rebuildCanvas(true);
            }
        });

        bedPresetSelect.addEventListener('change', function() {
            if (bedPresetSelect.value === 'glowforge') {
                const unit = unitSelect.value;
                if (unit === 'in') {
                    bedWidth = 19.5;
                    bedHeight = 11;
                } else {
                    bedWidth = 495.3;
                    bedHeight = 279.4;
                }
                bedWidthInput.value = bedWidth;
                bedHeightInput.value = bedHeight;
            }
            if (importedGroups.length > 0) {
                rebuildCanvas(true);
            }
        });

        bedWidthInput.addEventListener('change', function() {
            bedWidth = parseFloat(bedWidthInput.value) || 0;
            bedPresetSelect.value = 'custom';
            if (importedGroups.length > 0) {
                rebuildCanvas(false);
            }
        });

        bedHeightInput.addEventListener('change', function() {
            bedHeight = parseFloat(bedHeightInput.value) || 0;
            bedPresetSelect.value = 'custom';
            if (importedGroups.length > 0) {
                rebuildCanvas(false);
            }
        });

        autoPlaceBtn.addEventListener('click', autoPlace);

        // Undo/Redo buttons
        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);

        // Color toolbar
        colorSwatches.addEventListener('click', function(e) {
            const swatch = e.target.closest('.color-swatch');
            if (swatch) {
                applyColorToSelection(swatch.dataset.color);
            }
        });

        customColor.addEventListener('input', function() {
            if (selectedElements.size > 0) {
                applyColorToSelection(customColor.value);
            }
        });

        clearSelectionBtn.addEventListener('click', clearSelection);
        deleteSelectionBtn.addEventListener('click', deleteSelection);

        // File list actions (event delegation)
        document.getElementById('fileList').addEventListener('click', function(e) {
            const btn = e.target.closest('[data-action]');
            if (!btn) return;

            const action = btn.dataset.action;
            const groupId = parseInt(btn.dataset.groupId);

            if (action === 'select') {
                // Select all elements in this group
                const svg = previewArea.querySelector('svg');
                if (!svg) return;
                const groupG = svg.querySelector(`g[data-group-id="${groupId}"]`);
                if (!groupG) return;

                clearSelection();
                groupG.querySelectorAll('.selectable').forEach(el => {
                    el.classList.add('selected');
                    selectedElements.add(el);
                });
                updateSelectionInfo();
            } else if (action === 'ungroup') {
                ungroupFile(groupId);
            } else if (action === 'remove') {
                saveUndoState();
                importedGroups = importedGroups.filter(g => g.id !== groupId);
                // Clean up color overrides for this group
                for (const [key] of colorOverrides) {
                    if (key.startsWith(`${groupId}-`)) {
                        colorOverrides.delete(key);
                    }
                }
                rebuildCanvas(true);
            }
        });

        // Checkbox change → show/hide Group Selected button
        document.getElementById('fileList').addEventListener('change', function(e) {
            if (e.target.classList.contains('group-checkbox')) {
                updateGroupButton();
            }
        });

        // Group Selected button
        groupSelectedBtn.addEventListener('click', function() {
            const checked = document.querySelectorAll('.group-checkbox:checked');
            const ids = Array.from(checked).map(cb => parseInt(cb.dataset.groupId));
            groupSelectedFiles(ids);
        });

        clearAllBtn.addEventListener('click', function() {
            if (importedGroups.length === 0) return;
            saveUndoState();
            importedGroups = [];
            groupIdCounter = 0;
            colorOverrides.clear();
            selectedGroupId = null;
            rebuildCanvas(true);
        });

        // Move mode toggle
        document.getElementById('snapToggleBtn').addEventListener('click', function() {
            snapEnabled = !snapEnabled;
            this.textContent = snapEnabled ? 'Snap: ON' : 'Snap: OFF';
            this.classList.toggle('active', snapEnabled);
        });

        moveModeBtn.addEventListener('click', function() {
            moveMode = !moveMode;
            moveModeBtn.textContent = moveMode ? 'Move Mode: ON' : 'Move Mode: OFF';
            moveModeBtn.classList.toggle('active', moveMode);

            if (moveMode) {
                clearSelection();
                previewArea.classList.add('move-mode');
            } else {
                selectedGroupId = null;
                clearGroupHighlight();
                previewArea.classList.remove('move-mode');
                previewArea.classList.remove('dragging-group');
            }
        });

        // Reset view
        resetViewBtn.addEventListener('click', function() {
            if (!baseViewBox) return;
            viewCenterX = baseViewBox.x + baseViewBox.w / 2;
            viewCenterY = baseViewBox.y + baseViewBox.h / 2;
            viewZoom = 1;
            updateViewBox();
        });

        // Viewport: wheel zoom
        previewArea.addEventListener('wheel', handleWheel, { passive: false });

        // Interaction: mouse events on preview area
        previewArea.addEventListener('mousedown', handleMouseDown);
        previewArea.addEventListener('dblclick', handleDblClick);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        document.addEventListener('keydown', handleKeyDown);

        // Prevent context menu on middle-click
        previewArea.addEventListener('contextmenu', function(e) {
            if (e.button === 1) e.preventDefault();
        });
    </script>
</body>
</html>
